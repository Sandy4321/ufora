/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#pragma once

#include "../../core/Clock.hpp"
#include "../../core/Logging.hpp"
#include "../../core/math/Random.hpp"
#include "../../core/math/Smallest.hpp"
#include "../../core/IndexAllocator.hppml"
#include "../../core/containers/MapWithIndex.hpp"
#include "../PageLayoutCalculator/Neighborhood.hppml"
#include <set>
#include <vector>
#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>
#include <fstream>

namespace Cumulus {
namespace PageLayoutCalculator {

class Edges {
public:
	void addEdge(int32_t neighborhoodIndex, int32_t pageIndex, double weight)
		{
		if (mNeighborhoodToPageEdges.size() <= neighborhoodIndex)
			{
			mNeighborhoodToPageEdges.resize(neighborhoodIndex+1);
			for (auto& random: mNeighborhoodToNeighborhoodRandomEdges)
				random.resize(neighborhoodIndex + 1);
			}

		if (mPageToNeighborhoodEdges.size() <= pageIndex)
			mPageToNeighborhoodEdges.resize(pageIndex+1);

		insertSorted(mNeighborhoodToPageEdges[neighborhoodIndex],pageIndex, weight);
		insertSorted(mPageToNeighborhoodEdges[pageIndex],neighborhoodIndex, weight);
		}

	void dropNeighborhoodsAndPages(
					const boost::unordered_set<int32_t>& neighborhoodIndices, 
					const boost::unordered_set<int32_t>& pageIndices
					)
		{
		boost::unordered_set<int32_t> pageIndicesToShorten;

		for (auto ni: neighborhoodIndices)
			{
			for (auto edge: mNeighborhoodToPageEdges[ni])
				if (pageIndices.find(edge.first) == pageIndices.end())
					pageIndicesToShorten.insert(edge.first);

			mNeighborhoodToPageEdges[ni].clear();
			}

		for (auto pi: pageIndices)
			mPageToNeighborhoodEdges[pi].clear();

		for (auto pi: pageIndicesToShorten)
			clearPageIndices(mPageToNeighborhoodEdges[pi], neighborhoodIndices);
		}

	void dropNeighborhood(int32_t neighborhoodIndex)
		{
		lassert_dump(
			mNeighborhoodToNeighborhoodRandomEdges.size() == 0, 
			"we don't support changing the graph and maintaining random edges"
			);

		lassert(neighborhoodIndex >= 0 && neighborhoodIndex < mNeighborhoodToPageEdges.size());

		for (auto& edge: mNeighborhoodToPageEdges[neighborhoodIndex])
			{
			lassert(edge.first >= 0 && edge.first < mPageToNeighborhoodEdges.size());
			removeSorted(mPageToNeighborhoodEdges[edge.first], neighborhoodIndex);
			}

		mNeighborhoodToPageEdges[neighborhoodIndex].clear();
		}

	void clearRandomEdges()
		{
		mNeighborhoodToNeighborhoodRandomEdges.clear();
		}

	long randomEdgeVecCount() const
		{
		return mNeighborhoodToNeighborhoodRandomEdges.size();
		}

	void dropPage(int32_t pageIndex)
		{
		lassert(pageIndex >= 0 && pageIndex < mPageToNeighborhoodEdges.size());

		for (auto& edge: mPageToNeighborhoodEdges[pageIndex])
			{
			lassert(edge.first >= 0 && edge.first < mNeighborhoodToPageEdges.size());
			removeSorted(mNeighborhoodToPageEdges[edge.first], pageIndex);
			}

		mPageToNeighborhoodEdges[pageIndex].clear();
		}

	const std::vector<std::pair<int32_t, double> >& neighborhoodsForPage(long pageIndex) const
		{
		return mPageToNeighborhoodEdges[pageIndex];
		}

	const std::vector<std::pair<int32_t, double> >& pagesForNeighborhood(long neighborhoodIndex) const
		{
		return mNeighborhoodToPageEdges[neighborhoodIndex];
		}

	const std::vector<std::pair<int32_t, double> >& randomWalkVecForNeighborhood(long index, long edgeVector) const
		{
		return mNeighborhoodToNeighborhoodRandomEdges[edgeVector][index];
		}

	std::vector<std::vector<std::pair<int32_t, double> > >& createRandomEdgeVector()
		{
		mNeighborhoodToNeighborhoodRandomEdges.resize(mNeighborhoodToNeighborhoodRandomEdges.size()+1);
		mNeighborhoodToNeighborhoodRandomEdges.back().resize(mNeighborhoodToPageEdges.size());

		return mNeighborhoodToNeighborhoodRandomEdges.back();
		}

	std::vector<std::vector<std::pair<int32_t, double> > >& randomEdgeVector(long randomEdgeVector)
		{
		return mNeighborhoodToNeighborhoodRandomEdges[randomEdgeVector];
		}

private:
	void clearPageIndices(std::vector<std::pair<int32_t, double> >& edges, const boost::unordered_set<int32_t>& indices)
		{
		for (long k = 0; k < edges.size(); k++)
			if (indices.find(edges[k].first) != indices.end())
				{
				std::swap(edges[k], edges.back());
				edges.resize(edges.size()-1);
				k--;
				}
		}

	void insertSorted(std::vector<std::pair<int32_t, double> >& edges, int32_t index, double weight)
		{
		edges.push_back(make_pair(index, weight));
		}

	void removeSorted(std::vector<std::pair<int32_t, double> >& edges, int32_t index)
		{
		for (long k = 0; k < edges.size(); k++)
			if (edges[k].first == index)
				{
				if (k != edges.size() - 1)
					std::swap(edges[k], edges.back());
				edges.resize(edges.size()-1);
				return;
				}

		lassert(false);
		}

	std::vector<std::vector<std::pair<int32_t, double> > > mNeighborhoodToPageEdges;

	std::vector<std::vector<std::pair<int32_t, double> > > mPageToNeighborhoodEdges;

	std::vector<std::vector<std::vector<std::pair<int32_t, double> > > > mNeighborhoodToNeighborhoodRandomEdges;
};


class NeighborhoodSpectrumCalculator {
public:
	NeighborhoodSpectrumCalculator(long vectorCount, long seed = 1) : 
			mRandom(seed),
			mTotalBytesInAllPages(0),
			mTotalBytesInAllNeighborhoods(0)
		{
		mNeighborhoodPositions.resize(1);
		mPagePositions.resize(1);
		mWeights.resize(1);
		mPageWeight.resize(1);
		mTotalWeight.resize(1);
		mTotalWeight[0] = 0.0;

		mNeighborhoodPositions[0].resize(vectorCount);
		mPagePositions[0].resize(vectorCount);
		}

	void updateBlockStyle(long blocks, long pathsPerStep, long vectorsPerBlock, long updatePassesPerBlock)
		{
		for (long block = 0; block < blocks; block++)
			{
			addRandomPathsPerNeighborhood(
				pathsPerStep,
				vectorsPerBlock,
				block == 0 ? 0 : .75,
				block - 1
				);
			}

		for (long pass = blocks-1; pass >= 0; pass--)
			for (long k = 0; k < updatePassesPerBlock; k++)
				updateAllIndicesAndDimensions(0, .75, pass);

		clearRandomEdges();
		}

	//fraction of total energy (sum of squares, which add up to 'dimension')
	//explained using the pages
	double rSquared(long image) const
		{
		double total = 0.0;

		for (long i = 0; i < indexCount(); i++)
			if (isActive(i))
				{
				double w = 0.0;
				double t = 0.0;
				for (auto pageAndWeight: mEdges.pagesForNeighborhood(i))
					{
					w += pageAndWeight.second;
					t += 
						squaredDistanceBetweenNeighborhoodAndPage(
								image, 
								i,
								pageAndWeight.first
								)
						 * pageAndWeight.second;
					}

				total += (t/w) * getWeight(image, i);
				}

		return 1.0 - total / dimensionCount();
		}

	int64_t bytesInNeighborhoods() const
		{
		return mTotalBytesInAllNeighborhoods;
		}

	int64_t neighborhoodCount() const
		{
		return mNeighborhoodIndices.activeSize();
		}

	void reseedPositions()
		{
		for (long i = 0; i < imageCount(); i++)
			for (long d = 0; d < dimensionCount(); d++)
				{
				for (long k = 0; k < indexCount();k++)
					if (isActive(k))
						mNeighborhoodPositions[i][d][k] = mRandom();
				for (long k = 0; k < mPageIndices.size();k++)
					if (mPageIndices.isActive(k))
						mPagePositions[i][d][k] = mRandom();
				}
		}

	void perturbRandomly(double totalEnergy)
		{
		for (long i = 0; i < imageCount(); i++)
			{
			double energy = totalEnergy / std::sqrt(totalWeight(i));
			for (long d = 0; d < dimensionCount(); d++)
				{
				for (long k = 0; k < indexCount();k++)
					if (isActive(k))
						mNeighborhoodPositions[i][d][k] += mRandom() * energy;
					;
				for (long k = 0; k < mPageIndices.size();k++)
					if (mPageIndices.isActive(k))
						mPagePositions[i][d][k] += mRandom() * energy;
				}
			}
		}

	void updateUntilRSquaredHasStabilized(long image, double minRSquared, long maxUpdates)
		{
		double tDump = curClock();
		for (long k = 0; k < maxUpdates; k++)
			{
			updateAllIndicesAndDimensions(image);

			if (rSquared(image) > minRSquared)
				return;

			if (curClock() - tDump > 1.0)
				{
				LOG_WARN << "RSquared on pass " << k << " is " << rSquared(image);
				tDump = curClock();
				}
			}
		}

	void updateUntilEigenvaluesHaveStabilized(long image=0, double eigenvalueMoveThreshold=0.0000001, long maxUpdates=1000)
		{
		double t0 = curClock();
		double tDump = t0;
		for (long d = 0; d < dimensionCount(); d++)
			{
			double priorEigenvalueEstimate = impliedEigenvalue(image, d);
			for (long k = 0; k < maxUpdates; k++)
				{
				updateIndicesInDimension(image, d);
				double newEigenvalue = impliedEigenvalue(image, d);

				if (std::abs(newEigenvalue - priorEigenvalueEstimate) < eigenvalueMoveThreshold)
					k = maxUpdates;
				else
					priorEigenvalueEstimate = newEigenvalue;

				if (curClock() - tDump > 1.0)
					{
					LOG_WARN << "Eigenvalue for dim " << d << " on pass " << k << " is " << priorEigenvalueEstimate;
					tDump = curClock();
					}
				}
			}
		}

	void addDimension()
		{
		setDimensions(dimensionCount() + 1);
		}

	void setDimensions(long inDimensions)
		{
		for (long i = 0; i < imageCount(); i++)
			{
			while (dimensionCount() < inDimensions)
				{
				mNeighborhoodPositions[i].push_back(mNeighborhoodPositions[i].back());
				mPagePositions[i].push_back(mPagePositions[i].back());

				for (long k = 0; k < indexCount(); k++)
					if (isActive(k))
						mNeighborhoodPositions[i].back()[k] = mRandom();

				for (long k = 0; k < pageIndexCount(); k++)
					if (isActivePageIndex(k))
						mPagePositions[i].back()[k] = mRandom();
				}
			while(dimensionCount() > inDimensions)
				{
				mNeighborhoodPositions[i].pop_back();
				mPagePositions[i].pop_back();
				}
			}
		}

	void addImage()
		{
		mTotalWeight.push_back(mTotalWeight.back());
		mNeighborhoodPositions.push_back(mNeighborhoodPositions.back());
		mPagePositions.push_back(mPagePositions.back());
		mWeights.push_back(mWeights.back());
		mPageWeight.push_back(mPageWeight.back());
		}

	bool topTwoImpliedEigenvaluesAreIdentical(long image, double threshold = 0.001) const
		{
		double e1 = impliedEigenvalue(image, 0);
		double e2 = impliedEigenvalue(image, 1);

		return std::abs(e1 -e2) < threshold;
		}

	void rotateFirstTwoDimensionsToAchieveMaximumSplit()
		{
		Smallest<double> bestAngle;

		double curAngle = 0.0;
		double angleStepRadians = 3.1415926 * 2.0 / 50.0;

		for (long k = 0; k < 50; k++)
			{
			curAngle += 3.1415926 * 2.0 / 50.0;
			rotateFirstTwoDimensions(angleStepRadians);

			bestAngle.observe(curAngle, totalMinDistanceAmongstFirstTwoDimensions());
			}

		rotateFirstTwoDimensions(*bestAngle.smallest());
		}

	void splitByAverageDistance(long image, long d1, long d2, double splitWeight)
		{
		lassert(image >= 0 && image < imageCount());
		lassert(d1 >= 0 && d1 < dimensionCount());
		lassert(d2 >= 0 && d2 < dimensionCount());
		lassert(imageCount() == 2);

		for (long k = 0; k < indexCount();k++)
			if (isActive(k))
				{
				double w = splitWeight;

				if (averageDistanceFromPeersInDimension(image, k, d1) < averageDistanceFromPeersInDimension(image, k, d2))
					w = 1.0 - w;

				setWeight(0,k,w);
				setWeight(1,k,1.0-w);
				}
		}

	void splitByAverageDistance(long image, double weightTarget)
		{
		lassert(imageCount() == 2);

		double averageDistance = averageDistanceFromPeers(image);

		for (long k = 0; k < indexCount();k++)
			if (isActive(k))
				{
				double w = weightTarget;

				if (averageDistanceFromPeers(image, k) > averageDistance)
					w = 1.0 - w;

				setWeight(0,k,w);
				setWeight(1,k,1.0-w);
				}
		}

	void addNeighborhood(const Neighborhood& inKey, bool useRandomLayout = true)
		{
		if (mNeighborhoodIndices.hasKey(inKey))
			return;

		mTotalBytesInAllNeighborhoods += inKey.bytecount();

		long neighborhoodIndex = mNeighborhoodIndices.allocate(inKey);

		for (auto p: inKey.pages())
			{
			mPageCount[p] += 1;
			long pageIndex;

			if (mPageCount[p] == 1)
				{
				mImage = null();

				mTotalBytesInAllPages += p.bytecount();

				pageIndex = mPageIndices.allocate(p);

				for (long image = 0; image < imageCount(); image++)
					{
					for (auto& p: mPagePositions[image])
						if (pageIndex >= p.size())
							p.resize(pageIndex + 1);

					if (useRandomLayout)
						{
						for (long dim = 0; dim < mPagePositions[image].size(); dim++)
							mPagePositions[image][dim][pageIndex] = mRandom();
						}
					else
						{
						//this is a new page - we want to set its position in this image
						//to the average position of the pages in the neighborhood that
						//_do_ already exist
						for (long dim = 0; dim < mPagePositions[image].size(); dim++)
							{
							double positionSum = 0.0;
							double weight = 0.0;

							for (auto anotherP: inKey.pages())
								if (mPageIndices.hasKey(anotherP))
									{
									long anotherPIndex = mPageIndices.indexForKey(anotherP);
									positionSum += mPagePositions[image][dim][anotherPIndex];
									weight += 1.0;
									}

							if (weight > 0.0)
								mPagePositions[image][dim][pageIndex] = positionSum / weight;
							else
								mPagePositions[image][dim][pageIndex] = mRandom();
							}
						}

					if (pageIndex >= mPageWeight[image].size())
						{
						mPageWeight[image].resize(pageIndex + 1);
						mPageWeight[image][pageIndex] += p.bytecount();
						}
					}
				}
			else
				{
				pageIndex = mPageIndices.indexForKey(p);

				for (long image = 0; image < imageCount(); image++)
					mPageWeight[image][pageIndex] += p.bytecount();
				}

			mEdges.addEdge(neighborhoodIndex, pageIndex, p.bytecount() / 1024.0 / 1024.0);
			}

		for (long image = 0; image < imageCount(); image++)
			for (auto& p: mNeighborhoodPositions[image])
				if (neighborhoodIndex >= p.size())
					p.resize(neighborhoodIndex + 1);

		for (long image = 0; image < imageCount();image++)
			{
			if (neighborhoodIndex >= mWeights[image].size())
				mWeights[image].resize(mWeights[image].size()+1);

			mWeights[image][neighborhoodIndex] = .5;

			mTotalWeight[image] += .5;
			}

		if (useRandomLayout)
			{
			for (long image = 0; image < imageCount();image++)
				for (auto& p: mNeighborhoodPositions[image])
					p[neighborhoodIndex] = mRandom();
			}
		else
			{
			//the page positions should already be set, so we can just
			//recalculate the position of this one index.
			rebalanceSingleNode(neighborhoodIndex);
			}
		}

	void dropNeighborhoods(const std::set<Neighborhood>& inNeighborhoods)
		{
		boost::unordered_set<int32_t> neighborhoodIndices, pageIndices;

		for (auto n: inNeighborhoods)
			{
			long neighborhoodIndex = mNeighborhoodIndices.indexForKey(n);

			neighborhoodIndices.insert(neighborhoodIndex);
			mNeighborhoodIndices.release(neighborhoodIndex);

			mTotalBytesInAllNeighborhoods -= n.bytecount();

			for (auto p: n.pages())
				{
				long pageIndex = mPageIndices.indexForKey(p);
				for (long image = 0; image < imageCount(); image++)
					mPageWeight[image][pageIndex] -= p.bytecount();

				mPageCount[p] -= 1;

				if (mPageCount[p] == 0)
					{
					mImage = null();
					
					mTotalBytesInAllPages -= p.bytecount();
				
					mPageCount.erase(p);

					pageIndices.insert(pageIndex);
					mPageIndices.release(pageIndex);
					}
				}

			for (long image = 0; image < imageCount(); image++)
				mTotalWeight[image] -= mWeights[image][neighborhoodIndex];
			}

		mEdges.dropNeighborhoodsAndPages(neighborhoodIndices, pageIndices);
		}

	void dropNeighborhood(const Neighborhood& inKey)
		{
		long neighborhoodIndex = mNeighborhoodIndices.indexForKey(inKey);

		mTotalBytesInAllNeighborhoods -= inKey.bytecount();
		
		for (auto p: inKey.pages())
			{
			long pageIndex = mPageIndices.indexForKey(p);
			for (long image = 0; image < imageCount(); image++)
				mPageWeight[image][pageIndex] -= p.bytecount();

			mPageCount[p] -= 1;

			if (mPageCount[p] == 0)
				{
				mImage = null();
				
				mTotalBytesInAllPages -= p.bytecount();
			
				mPageCount.erase(p);
				mPageIndices.release(pageIndex);
				mEdges.dropPage(pageIndex);
				}
			}

		mEdges.dropNeighborhood(neighborhoodIndex);
		mNeighborhoodIndices.release(neighborhoodIndex);

		for (long image = 0; image < imageCount(); image++)
			mTotalWeight[image] -= mWeights[image][neighborhoodIndex];
		}

	void clearRandomEdges()
		{
		mEdges.clearRandomEdges();
		}

	void addRandomPathsPerNeighborhood(
					long pathLength, 
					long vecCount,
					double fracFromExistingRandomWalk,
					long randomWalkVec
					)
		{
		std::vector<std::vector<pair<int32_t, double> > >& toAdd = mEdges.createRandomEdgeVector();

		for (long k = 0; k < indexCount(); k++)
			for (long v = 0; v < vecCount; v++)
				if (isActive(k))
					{
					pair<int32_t, double> indexAndWeight = 
						pullRandomNeighborhoodWalk(
							k, 
							pathLength, 
							fracFromExistingRandomWalk,
							randomWalkVec
							);

					toAdd[k].push_back(indexAndWeight);
					toAdd[indexAndWeight.first].push_back(make_pair(k,indexAndWeight.second));
					}
		}

	pair<int32_t, double> pullRandomNeighborhoodWalk(
				long index, 
				long pathLength, 
				double fracFromExistingRandomWalk,
				long randomWalkVec
				)
		{
		double curWeight = 1.0;
		while (pathLength > 0)
			{
			pair<int32_t, double> neighborhoodAndWeight;

			if (fracFromExistingRandomWalk > 0.0 && mRandom() < fracFromExistingRandomWalk)
				{
				neighborhoodAndWeight = 
					randomNeighborhoodForNeighborhood(index, randomWalkVec);
				}
			else
				{
				pair<int32_t, double> pageAndWeight = randomPageForNeighborhood(index);

				neighborhoodAndWeight = randomNeighborhoodForPage(pageAndWeight.first);

				neighborhoodAndWeight.second *= pageAndWeight.second;
				}

			index = neighborhoodAndWeight.first;
			curWeight *= neighborhoodAndWeight.second;

			pathLength--;
			}

		return make_pair(index, curWeight);
		}

	pair<int32_t, double> randomEdge(const std::vector<pair<int32_t, double> >& edges)
		{
		double totalWeight = 0;
		for (auto indexAndWeight: edges)
			totalWeight += indexAndWeight.second;

		totalWeight *= mRandom();

		for (auto indexAndWeight: edges)
			{
			totalWeight -= indexAndWeight.second;

			if (totalWeight <= 0.0)
				return make_pair(indexAndWeight.first, 1.0);
			}

		return make_pair(edges[0].first, 1.0);
		}

	pair<int32_t, double> randomNeighborhoodForNeighborhood(long index, long randomWalkVec)
		{
		return randomEdge(mEdges.randomWalkVecForNeighborhood(index, randomWalkVec));
		}

	pair<int32_t, double> randomPageForNeighborhood(long index)
		{
		return randomEdge(mEdges.pagesForNeighborhood(index));
		}

	pair<int32_t, double> randomNeighborhoodForPage(long index)
		{
		return randomEdge(mEdges.neighborhoodsForPage(index));
		}

	Neighborhood imageAsNeighborhood() const
		{
		if (!mImage)
			{
			Neighborhood n;
			for (auto pAndCount: mPageCount)
				n = n + pAndCount.first;
			mImage = n;
			}

		return *mImage;
		}

	size_t imageCount() const
		{
		return mNeighborhoodPositions.size();
		}

	void updateAllIndicesAndDimensions()
		{
		for (long i = 0; i < imageCount();i++)
			updateAllIndicesAndDimensions(i);
		}

	void updateAllIndicesAndDimensions(long image, double randomWalkWeight = 0.0, long randomWalkVec = 0)
		{
		for (long dim = 0; dim < dimensionCount(); dim++)
			updateIndicesInDimension(image, dim, randomWalkWeight, randomWalkVec);
		}

	size_t dimensionCount() const
		{
		return mNeighborhoodPositions[0].size();
		}

	size_t activeIndexCount() const
		{
		return mNeighborhoodIndices.activeSize();
		}

	size_t indexCount() const
		{
		return mNeighborhoodIndices.size();
		}

	bool isActivePageIndex(long index) const
		{
		return mPageIndices.isActive(index);
		}

	long pageIndexCount() const
		{
		return mPageIndices.size();
		}

	bool isActive(long index) const
		{
		return mNeighborhoodIndices.isActive(index);
		}

	double totalMinDistanceAmongstFirstTwoDimensions() const
		{
		return totalMinDistanceAmongst(0,1);
		}

	double medianSquaredDistanceInDimension(long dim, double percentile = .5) const
		{
		std::vector<pair<double, double> > elts;

		for (long k = 0; k < indexCount(); k++)
			if (isActive(k))
				{
				double d1 = averageDistanceFromPeersInDimension(0, k, dim);

				elts.push_back(make_pair(d1, mWeights[0][k]));
				}

		std::sort(elts.begin(), elts.end());

		double cumWeight = 0;

		for (auto xAndW: elts)
			{
			cumWeight += xAndW.second;
			if (cumWeight > percentile * mTotalWeight[0])
				return xAndW.first;
			}

		return elts.back().first;
		}

	double averageSquaredDistanceInDimension(long dim) const
		{
		double total = 0;
		for (long k = 0; k < indexCount(); k++)
			if (isActive(k))
				{
				double d1 = averageDistanceFromPeersInDimension(0, k, dim);

				total += d1 * mWeights[0][k];
				}

		return total / mTotalWeight[0];
		}

	static bool contains(const std::vector<long>& d, long l)
		{
		for (auto x: d)
			if (x == l)
				return true;

		return false;
		}

	double correlationBetweenSquaredPositions(long image, long d1, long d2) const
		{
		double meanSqD1 = 0.0;
		double meanSqD2 = 0.0;
		
		for (long k = 0; k < indexCount();k++)
			if (isActive(k))
				{
				meanSqD1 += mNeighborhoodPositions[image][d1][k] * mNeighborhoodPositions[image][d1][k] * mWeights[image][k];
				meanSqD2 += mNeighborhoodPositions[image][d2][k] * mNeighborhoodPositions[image][d2][k] * mWeights[image][k];
				}

		meanSqD1 /= mTotalWeight[image];
		meanSqD2 /= mTotalWeight[image];

		double sd1 = 0.0;
		double sd2 = 0.0;
		double sd12 = 0.0;

		for (long k = 0; k < indexCount();k++)
			if (isActive(k))
				{
				double x = mNeighborhoodPositions[image][d1][k] * mNeighborhoodPositions[image][d1][k] - meanSqD1;
				double y = mNeighborhoodPositions[image][d2][k] * mNeighborhoodPositions[image][d2][k] - meanSqD2;

				sd1 += x * x * mWeights[image][k];
				sd2 += y * y * mWeights[image][k];
				sd12 += x * y * mWeights[image][k];
				}

		sd1 /= mTotalWeight[image];
		sd2 /= mTotalWeight[image];
		sd12 /= mTotalWeight[image];

		return sd12 / std::sqrt(sd1 * sd2);
		}

	long bestDimensionToAdd(const std::vector<long>& dims1, const std::vector<long>& dims2) const
		{
		Smallest<long> best;

		for (long d = 0; d < dimensionCount(); d++)
			if (!contains(dims1, d) && !contains(dims2,d))
				{
				std::vector<long> d2 = dims2;
				d2.push_back(d);

				best.observe(d, totalMinDistanceAmongst(dims1, d2));
				}

		return *best.smallest();
		}

	long bestDimensionGroupFor(long index, const std::vector<long>& dims1, const std::vector<long>& dims2) const
		{
		double d1 = 0.0;
		double d2 = 0.0;

		for (auto d: dims1)
			d1 += averageDistanceFromPeersInDimension(0, index, d);

		for (auto d: dims2)
			d2 += averageDistanceFromPeersInDimension(0, index, d);

		return d1 < d2 ? 0 : 1;
		}

	double totalMinDistanceAmongst(const std::vector<long>& dims1, const std::vector<long>& dims2) const
		{
		double total = 0;
		for (long k = 0; k < indexCount(); k++)
			if (isActive(k))
				{
				double d1 = 0.0;
				double d2 = 0.0;

				for (auto d: dims1)
					d1 += averageDistanceFromPeersInDimension(0, k, d);

				for (auto d: dims2)
					d2 += averageDistanceFromPeersInDimension(0, k, d);

				total += std::min(d1, d2);
				}

		return total;
		}

	double totalMinDistanceAmongst(long dim1, long dim2) const
		{
		double total = 0;
		for (long k = 0; k < indexCount(); k++)
			if (isActive(k))
				{
				double d1 = averageDistanceFromPeersInDimension(0, k, dim1);
				double d2 = averageDistanceFromPeersInDimension(0, k, dim2);

				total += std::min(d1, d2);
				}
		return total;
		}

	double averageDistanceFromPeersInDimension(long image, long index, long dimension) const
		{
		double total = 0.0;
		double totalWeight = 0.0;

		for (auto pageAndWeight: mEdges.pagesForNeighborhood(index))
			{
			double pageWeight = pageWeightInImage(pageAndWeight.first, image);

			totalWeight += pageAndWeight.second * pageWeight;
			total += 
				squaredDistanceBetweenNeighborhoodAndPageInDimension(
						image, 
						index, 
						pageAndWeight.first,
						dimension
						)
				 * pageAndWeight.second * pageWeight;
			}

		if (totalWeight > 0.0)
			return total / totalWeight;
		return 0.0;
		}

	double squaredDistanceBetweenNeighborhoodAndPageInDimension(long image, long nIndex, long pIndex, long d) const
		{
		double diff = position(image, nIndex,d) - pagePosition(image, pIndex, d);
		return diff * diff;
		}

	void rotateFirstTwoDimensions(double radians)
		{
		double x1 = std::cos(radians);
		double x2 = std::sin(radians);

		for (long k = 0; k < indexCount();k++)
			{
			double a = mNeighborhoodPositions[0][0][k];
			double b = mNeighborhoodPositions[0][1][k];

			mNeighborhoodPositions[0][0][k] = a * x1 - b * x2;
			mNeighborhoodPositions[0][1][k] = a * x2 + b * x1;
			}

		for (long k = 0; k < mPageIndices.size();k++)
			{
			double a = mPagePositions[0][0][k];
			double b = mPagePositions[0][1][k];

			mPagePositions[0][0][k] = a * x1 - b * x2;
			mPagePositions[0][1][k] = a * x2 + b * x1;
			}
		}

	//between two dimensions, migrate weight so that neighborhoods are contained
	//within the image in which they are closest to their peers
	double splitWeights(double extremeWeight = .99999999, double moveThreshold = 0.0001, double moveAmount = 2.0)
		{
		lassert(imageCount() == 2);	

		double totalWeightMoved = 0.0;

		for (long k = 0; k < indexCount(); k++)
			if (isActive(k))
				{
				double highWeight = getWeight(1, k);

				double highWeightLogOdds = std::log(highWeight / (1.0 - highWeight));

				double diff = 
					averageNormalizedDistanceFromPeers(0, k) 
						- averageNormalizedDistanceFromPeers(1, k);

				if (diff > moveThreshold)
					highWeightLogOdds += moveAmount;
					else
				if (diff < -moveThreshold)
					highWeightLogOdds -= moveAmount;
				else
					highWeightLogOdds = highWeightLogOdds / 2.0;

				//for some strange reason, exp gets _very_ slow if the value is
				//close to zero?
				if (highWeightLogOdds < 0.001 && highWeightLogOdds > -0.001)
					highWeightLogOdds = 0.0;

				double newHighWeight = std::exp(highWeightLogOdds);
				newHighWeight = newHighWeight / (1.0 + newHighWeight);

				if (newHighWeight > extremeWeight)
					newHighWeight = extremeWeight;
				if (newHighWeight < 1.0 - extremeWeight)
					newHighWeight = 1.0 - extremeWeight;

				totalWeightMoved += std::abs(newHighWeight - highWeight);

				setWeight(1, k, newHighWeight);
				setWeight(0, k, 1.0-newHighWeight);
				}

		return totalWeightMoved;
		}

	void dumpInOrder(std::string fname, long image = 0, double weightThreshold = 0.0)
		{
		std::vector<long> indices;

		for (long k = 0; k < indexCount();k++)
			if (isActive(k) && mWeights[image][k] > weightThreshold)
				indices.push_back(k);

		dump(fname, indices, image);
		}

	void dump(std::string fname, long image = 0, double weightThreshold = 0.0)
		{
		std::vector<long> indices;

		orderIndicesLinearly(indices, image, weightThreshold);

		dump(fname, indices, image);
		}

	void dump(std::string fname, const std::vector<long>& indicesInOrder, long image = 0)
		{
		ofstream s(fname.c_str());

		s << "vals = [";

		for (long dim = 0; dim < dimensionCount(); dim++)
			{
			s << "\t[";

			for (long k = 0; k < indicesInOrder.size();k++)
				{
				long index = indicesInOrder[k];
				s << position(image, index, dim);
				if (k+1 < indicesInOrder.size())
					s << ",";
				}
			s << "],\n";
			}
		s << "]\n";

		s << "weights=[";

		for (long k = 0; k < indicesInOrder.size();k++)
			{
			long index = indicesInOrder[k];
			s << std::log(mWeights[image][index] / (1.0 - mWeights[image][index]));
			if (k+1 < indicesInOrder.size())
				s << ",";
			}
		s << "]\n";

		s << "squares=[";

		for (long d = 1; d <= dimensionCount(); d++)
			{
			s << "[";
			for (long k = 0; k < indicesInOrder.size();k++)
				{
				long index = indicesInOrder[k];
				s << sumOfSquaredPositions(image, index, d);
				if (k+1 < indicesInOrder.size())
					s << ",";
				}
			s << "],";
			}

		s << "]\n";

		s << "eigenvalues=[";

		for (long k = 0; k < dimensionCount();k++)
			{
			s << impliedEigenvalue(0,k);
			if (k+1 < dimensionCount())
				s << ",";
			}
		s << "]\n";

		s << "\n\
import matplotlib as mpl\n\
from mpl_toolkits.mplot3d import Axes3D\n\
import numpy as np\n\
import matplotlib.pyplot as plt\n\
\n\
ct = len(vals[0])\n\
slices = 4;\n\
def c(x,step=100):\n\
	return [sum(x[ix*step:(ix+1)*step]) for ix in range(len(x)/step)]\n\
if len(vals)>2:\n\
	fig = plt.figure()\n\
	ax = fig.gca(projection='3d')\n\
	per = ct / slices\n\
	for ix in range(slices):\n\
		ax.plot(\n\
			vals[0][ix*per:(ix+1)*per], \n\
			vals[1][ix*per:(ix+1)*per], \n\
			vals[2][ix*per:(ix+1)*per]\n\
			)\n\
	\n\
	plt.show()\n\
for ix in range(len(vals)):\n\
	plt.plot(vals[ix],label='dim %s. eigenvalue=%s' % (ix,eigenvalues[ix]))\n\
	plt.legend()\n\
	plt.show()\n\
plt.plot(weights,label=\"weight\")\n\
plt.legend()\n\
plt.show()\n\
for ix in range(len(squares)):\n\
	plt.plot(c(squares[ix]),label=\"squares %s\"%ix)\n\
plt.legend()\n\
plt.show()\n\
";
		}

	void dump(std::string fname, const MapWithIndex<long, long>& indexToGroup, long image = 0)
		{
		ofstream s(fname.c_str());

		s << "vals = [";

		for (auto& groupToIndices: indexToGroup.getValueToKeys())
			{
			s << "[";

			for (long dim = 0; dim < dimensionCount(); dim++)
				{
				s << "[";
				for (auto index: groupToIndices.second)
					s << position(image, index, dim) << ",";
				s << "],";
				}
			s << "],";
			}
		s << "]\n";

		s << "\n\
import matplotlib as mpl\n\
from mpl_toolkits.mplot3d import Axes3D\n\
import numpy as np\n\
import matplotlib.pyplot as plt\n\
\n\
ct = len(vals[0])\n\
def c(x,step=100):\n\
	return [sum(x[ix*step:(ix+1)*step]) for ix in range(len(x)/step)]\n\
if len(vals[0])>2:\n\
	fig = plt.figure()\n\
	ax = fig.gca(projection='3d')\n\
	for ix in range(len(vals)):\n\
		dims = vals[ix]\n\
		ax.scatter(dims[0], dims[1], dims[2],label='group %s' % ix)\n\
	\n\
	plt.legend()\n\
	plt.show()\n\
";
		}

	void dumpPages(std::string fname, const std::vector<Fora::PageId>& pages, long image = 0)
		{
		ofstream s(fname.c_str());

		s << "vals = [";

		for (long dim = 0; dim < dimensionCount(); dim++)
			{
			s << "\t[";

			for (long k = 0; k < pages.size();k++)
				{
				long index = mPageIndices.indexForKey(pages[k]);
				s << mPagePositions[image][dim][index];
				if (k+1 < pages.size())
					s << ",";
				}
			s << "],\n";
			}
		s << "]\n";

		s << "\n\
import matplotlib as mpl\n\
from mpl_toolkits.mplot3d import Axes3D\n\
import numpy as np\n\
import matplotlib.pyplot as plt\n\
\n\
ct = len(vals[0])\n\
slices = 4;\n\
if len(vals)>2:\n\
	fig = plt.figure()\n\
	ax = fig.gca(projection='3d')\n\
	per = ct / slices\n\
	for ix in range(slices):\n\
		ax.plot(\n\
			vals[0][ix*per:(ix+1)*per], \n\
			vals[1][ix*per:(ix+1)*per], \n\
			vals[2][ix*per:(ix+1)*per]\n\
			)\n\
	\n\
	plt.show()\n\
for ix in range(len(vals)):\n\
	plt.plot(vals[ix],label=str(ix))\n\
	plt.legend()\n\
	plt.show()\n\
";
		}

	double sumOfSquaredPositions(long image, long index) const
		{
		double res = 0;

		for (long dim = 0; dim < dimensionCount(); dim++)
			res += position(image,index,dim) * position(image,index,dim);

		return res;
		}

	double sumOfSquaredPositions(long image, long index, long maxDim) const
		{
		double res = 0;

		for (long dim = 0; dim < maxDim; dim++)
			res += position(image,index,dim) * position(image,index,dim);

		return res;
		}

	double position(long image, long index, long dim) const
		{
		lassert(image >= 0 && image < imageCount());
		lassert_dump(dim >= 0 && dim < dimensionCount(), dim << " vs. " << dimensionCount());
		lassert(index >= 0 && index < indexCount());
		lassert(isActive(index));

		return mNeighborhoodPositions[image][dim][index];
		}

	bool hasNeighborhood(const Neighborhood& in) const
		{
		return mNeighborhoodIndices.hasKey(in);
		}

	long indexForNeighborhood(const Neighborhood& in) const
		{
		return mNeighborhoodIndices.indexForKey(in);
		}

	const Neighborhood& neighborhoodForIndex(long index) const
		{
		lassert(mNeighborhoodIndices.isActive(index));
		return mNeighborhoodIndices.keyForIndex(index);
		}

	void setWeight(long image, long index, double weight)
		{
		lassert(image >= 0 && image < imageCount());
		lassert(isActive(index));
		mTotalWeight[image] += weight - mWeights[image][index];
		mWeights[image][index] = weight;
		}

	double getWeight(long image, long index) const
		{
		lassert(image >= 0 && image < imageCount());
		lassert(isActive(index));
		return mWeights[image][index];
		}

	double totalWeight(long image) const
		{
		return mTotalWeight[image];
		}

	double meanOfDimension(long image, long dim) const
		{
		double total = 0.0;
		double weight = 0.0;

		for (long k = 0; k < indexCount();k++)
			{
			if (isActive(k))
				{
				total += position(image, k, dim) * mWeights[image][k];
				weight += mWeights[image][k];
				}
			}

		if (weight > 0.0)
			return total / weight;
		return 0.0;
		}

	double dimensionDotProduct(long image, long dim1, long dim2) const
		{
		double total = 0.0;
		double weight = 0.0;

		for (long k = 0; k < indexCount();k++)
			if (isActive(k))
				{
				total += position(image, k, dim1) * position(image, k, dim2) * mWeights[image][k];
				weight += mWeights[image][k];
				}

		return total;
		}

	void rebalanceSingleNode(long index)
		{
		lassert(isActive(index));

		for (long image = 0; image < imageCount(); image++)
			for (long dim = 0; dim < dimensionCount(); dim++)
				mNeighborhoodPositions[image][dim][index] = averageForIndexInDimension(image, index, dim);
		}

	void rebalanceSingleNode(Neighborhood n)
		{
		rebalanceSingleNode(indexForNeighborhood(n));
		}

	double impliedEigenvalue(long image, long dim) const
		{
		double res = 0.0;
		double weights = 0.0;

		for (long k = 0; k < indexCount(); k++)
			if (isActive(k))
				{
				res = res + position(image,k,dim) * 
					averageForIndexInDimension(image,k,dim) * mWeights[image][k];
				}

		return res;
		}

	double averageDistanceFromPeers(long image) const
		{
		double d = 0.0;
		double w = 0.0;

		for (long k = 0; k < indexCount(); k++)
			if (isActive(k))
				{
				d += averageDistanceFromPeers(image, k) * mWeights[image][k];
				w += mWeights[image][k];
				}

		if (w > 0.0)
			return d / w;
		return 0.0;
		}

	double averageNormalizedDistanceFromPeers(long image, long index) const
		{
		return averageDistanceFromPeers(image, index) * std::sqrt(totalWeight(image));
		}

	double averageDistanceFromPeers(long image, long index) const
		{
		double total = 0.0;
		double totalWeight = 0.0;

		for (auto pageAndWeight: mEdges.pagesForNeighborhood(index))
			{
			double pageWeight = pageWeightInImage(pageAndWeight.first, image);
			totalWeight += pageAndWeight.second * pageWeight;
			total += 
				squaredDistanceBetweenNeighborhoodAndPage(
						image, 
						index, 
						pageAndWeight.first
						)
				 * pageAndWeight.second * pageWeight;
			}

		if (totalWeight > 0.0)
			return total / totalWeight;
		return 0.0;
		}

	double pageWeightInImage(long pageIx, long image) const
		{
		return 1.0 / mPageWeight[image][pageIx];
		}

	double squaredDistanceBetweenNeighborhoodAndPage(long image, long nIndex, long pIndex) const
		{
		double res = 0.0;

		for (long d = 0; d < dimensionCount(); d++)
			{
			double diff = position(image, nIndex,d) - pagePosition(image, pIndex, d);
			res += diff * diff;
			}

		return res;
		}

	double pagePosition(long image, long index, long dim) const
		{
		return mPagePositions[image][dim][index];
		}

	double squaredDistanceBetween(long image, long index1, long index2) const
		{
		double res = 0.0;

		for (long d = 0; d < dimensionCount(); d++)
			{
			double diff = position(image, index1,d) - position(image, index2,d);
			res += diff * diff;
			}

		return res;
		}

	Nullable<long> closestNodeTo(long index, long image = 0, double weightThreshold = 0) const
		{
		Smallest<long> closest;

		for (auto pageAndWeight: mEdges.pagesForNeighborhood(index))
			for (auto neighborhoodAndWeight: mEdges.neighborhoodsForPage(pageAndWeight.first))
				if (neighborhoodAndWeight.first != index && 
							mWeights[image][neighborhoodAndWeight.first] > weightThreshold)
					closest.observe(
						neighborhoodAndWeight.first, 
						squaredDistanceBetween(image, neighborhoodAndWeight.first, index)
						);

		return closest.smallest();
		}

	void orderIndicesLinearly(
				std::vector<long>& outIndicesInOrder, 
				long image = 0,
				double weightThreshold = 0.0
				) const
		{
		double t0 = curClock();

		outIndicesInOrder.clear();

		std::deque<long> indices;

		//start by picking the minimum value in dimension 0
		std::vector<std::pair<double, int32_t> > indicesAndDim0;

		for (long k = 0; k < indexCount(); k++)
			if (isActive(k) && mWeights[image][k] > weightThreshold)
				indicesAndDim0.push_back(std::pair<double, int32_t>(position(image,k,0), k));

		std::sort(indicesAndDim0.begin(), indicesAndDim0.end());

		if (!indicesAndDim0.size())
			return;

		for (auto offsetAndIndex: indicesAndDim0)
			outIndicesInOrder.push_back(offsetAndIndex.second);
		}

	void copyFrom(NeighborhoodSpectrumCalculator& calc)
		{
		mTotalWeight = calc.mTotalWeight;
		mPageCount = calc.mPageCount;
		mNeighborhoodPositions = calc.mNeighborhoodPositions;
		mPagePositions = calc.mPagePositions;
		mWeights = calc.mWeights;
		mNeighborhoodIndices = calc.mNeighborhoodIndices;
		mPageIndices = calc.mPageIndices;
		mEdges = calc.mEdges;
		}

	void updateIndicesInDimension(long image, long dimension, double randomWalkWeight = 0.0, long randomWalkVec = 0)
		{
		updatePagePositions(image, dimension);
		
		if (randomWalkWeight > 0.0)
			updateNeighborhoodPositionsUsingRandomWalk(image, dimension, randomWalkWeight, randomWalkVec);
		else
			updateNeighborhoodPositions(image, dimension);

		forceZeroMean(image, dimension);

		for (long d = 0; d < dimension; d++)
			forceOrthogonal(image, d, dimension);

		forceNorm1(image, dimension);
		}

	int64_t bytesInPages() const
		{
		return mTotalBytesInAllPages;
		}

	const boost::unordered_map<Fora::PageId, long>& getPageCounts() const
		{
		return mPageCount;
		}

	bool hasPage(Fora::PageId p) const
		{
		auto it = mPageCount.find(p);

		return it != mPageCount.end() && it->second > 0;
		}

	int64_t pageCount() const
		{
		return mPageCount.size();
		}

private:
	void updateNeighborhoodPositionsUsingRandomWalk(long image, long dimension, double randomWalkWeight, long randomWalkVec)
		{
		double* neighborhoodPositions = &mNeighborhoodPositions[image][dimension][0];
		double* pagePositions = &mPagePositions[image][dimension][0];

		for (long k = 0; k < mNeighborhoodIndices.size();k++)
			if (mNeighborhoodIndices.isActive(k))
				{
				double totalWeight = 0.0;
				double total = 0.0;

				for (auto indexAndWeight: mEdges.pagesForNeighborhood(k))
					{
					double w = indexAndWeight.second;
					totalWeight += w;
					total += w * pagePositions[indexAndWeight.first];
					}

				double totalWeight2 = 0.0;
				double total2 = 0.0;

				for (auto indexAndWeight: mEdges.randomWalkVecForNeighborhood(k, randomWalkVec))
					{
					double w = indexAndWeight.second;

					totalWeight2 += w;
					total2 += w * neighborhoodPositions[indexAndWeight.first];
					}

				if (totalWeight > 0.0 && totalWeight2 > 0.0)
					{
					neighborhoodPositions[k] = 
						total / totalWeight * (1.0 - randomWalkWeight) + 
						total2 / totalWeight2 * randomWalkWeight
						;
					}
					else
				if (totalWeight > 0.0)
					neighborhoodPositions[k] = total / totalWeight;
					else
				if (totalWeight2 > 0.0)
					neighborhoodPositions[k] = total2 / totalWeight2;
				}
		}

	double averageForIndexInDimension(long image, long index, long dim) const
		{
		double total = 0.0;
		double totalWeight = 0.0;

		const double* pagePositions = &mPagePositions[image][dim][0];

		for (auto indexAndWeight: mEdges.pagesForNeighborhood(index))
			{
			double w = indexAndWeight.second;
			totalWeight += w;
			total += w * pagePositions[indexAndWeight.first];
			}

		return total / totalWeight;
		}

	void forceZeroMean(long image, long dimension)
		{
		double* weights = &mWeights[image][0];
		double* neighborhoodPositions = &mNeighborhoodPositions[image][dimension][0];
		
		double total = 0.0;
		double active = 0.0;

		for (long k = 0; k < mNeighborhoodIndices.size();k++)
			if (mNeighborhoodIndices.isActive(k))
				{
				total += neighborhoodPositions[k] * weights[k];
				active += weights[k];
				}

		if (active <= 0.0)
			return;

		total /= active;

		for (long k = 0; k < mNeighborhoodIndices.size();k++)
			if (mNeighborhoodIndices.isActive(k))
				neighborhoodPositions[k] -= total;
		}

	void forceNorm1(long image, long dimension)
		{
		double* weights = &mWeights[image][0];
		double* neighborhoodPositions = &mNeighborhoodPositions[image][dimension][0];
		
		double total = 0.0;

		for (long k = 0; k < indexCount();k++)
			if (isActive(k))
				total += neighborhoodPositions[k] * neighborhoodPositions[k] * weights[k];

		if (total <= 0.0)
			return;

		total = std::sqrt(total);

		for (long k = 0; k < indexCount();k++)
			if (isActive(k))
				neighborhoodPositions[k] /= total;
		}

	void forceOrthogonal(long image, long dim1, long dim2)
		{
		double* neighborhoodPositions1 = &mNeighborhoodPositions[image][dim1][0];
		double* neighborhoodPositions2 = &mNeighborhoodPositions[image][dim2][0];
		double* weights = &mWeights[image][0];
		
		double total = 0.0;
		double weight = 0.0;

		for (long k = 0; k < indexCount();k++)
			if (isActive(k))
				total += neighborhoodPositions1[k] * neighborhoodPositions2[k] * weights[k];

		for (long k = 0; k < indexCount();k++)
			if (isActive(k))
				neighborhoodPositions2[k] -= neighborhoodPositions1[k] * total;
		}

	void updatePagePositions(long image, long dimension)
		{
		double* neighborhoodWeights = &mWeights[image][0];
		double* neighborhoodPositions = &mNeighborhoodPositions[image][dimension][0];
		double* pagePositions = &mPagePositions[image][dimension][0];

		for (long k = 0; k < mPageIndices.size();k++)
			if (mPageIndices.isActive(k))
				{
				double totalWeight = 0.0;
				double total = 0.0;

				for (auto indexAndWeight: mEdges.neighborhoodsForPage(k))
					{
					double w = indexAndWeight.second * neighborhoodWeights[indexAndWeight.first];
					totalWeight += w;
					total += w * neighborhoodPositions[indexAndWeight.first];
					}

				if (totalWeight > 0.0)
					pagePositions[k] = total / totalWeight;
				}
		}

	void updateNeighborhoodPositions(long image, long dimension)
		{
		double* neighborhoodPositions = &mNeighborhoodPositions[image][dimension][0];
		double* pagePositions = &mPagePositions[image][dimension][0];

		for (long k = 0; k < mNeighborhoodIndices.size();k++)
			if (mNeighborhoodIndices.isActive(k))
				{
				double totalWeight = 0.0;
				double total = 0.0;

				for (auto indexAndWeight: mEdges.pagesForNeighborhood(k))
					{
					double w = indexAndWeight.second;
					totalWeight += w;
					total += w * pagePositions[indexAndWeight.first];
					}

				if (totalWeight > 0.0)
					neighborhoodPositions[k] = total / totalWeight;
				}
		}

	int64_t mTotalBytesInAllPages;

	int64_t mTotalBytesInAllNeighborhoods;

	mutable Nullable<Neighborhood> mImage;

	boost::unordered_map<Fora::PageId, long> mPageCount;

	std::vector<std::vector<std::vector<double> > > mNeighborhoodPositions;

	std::vector<std::vector<std::vector<double> > > mPagePositions;

	std::vector<std::vector<double> > mWeights;

	std::vector<std::vector<double> > mPageWeight;

	IndexAllocator<Neighborhood> mNeighborhoodIndices;

	IndexAllocator<Fora::PageId> mPageIndices;

	Edges mEdges;

	Ufora::math::Random::Uniform<double> mRandom;

	std::vector<double> mTotalWeight;
};

}
}

