/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#include <unordered_map>
#include "PythonAstConverter.hppml"
#include "PythonListConverter.hppml"
#include "PythonTupleConverter.hppml"
#include "PythonDictConverter.hppml"
#include "PythonToForaConversionError.hppml"
#include "PythonConstantConverter.hppml"
#include "../../Judgment/JudgmentOnValue.hppml"
#include "../../Core/ImplValContainerUtilities.hppml"
#include "../../Language/FunctionStage1Simulation.hppml"
#include "../../Language/ExpressionLocationMetadata.hppml"
#include "../../../core/cppml/CPPMLVisit.hppml"
#include "../../../core/cppml/CPPMLTransform.hppml"
#include "../../../core/Logging.hpp"
#include "../../Language/RebindFree.hppml"
#include "../../Language/ParserExpressions.hppml"
#include "../../Language/ClassMediatorBindings.hppml"

#define PYFORA_CONVERSION_ERROR_MESSAGE "Pyfora can't convert this code. See http://docs.pyfora.com/en/latest/tutorials/intro.html#pure-python"


constexpr auto __inline_fora_string = "__inline_fora";


namespace {

using namespace Fora;

using SetOfStringPairs = std::set<std::pair<std::string, std::string>>;

constexpr char MEMBERS_TUPLE_NAME[] = "@m";

void assertValidNameIdentifier(
        const std::string& identifier,
        const SimpleParseRange& extent
        )
    {
    if (identifier == __inline_fora_string)
        throw PythonToForaConversionError(
            std::string("in pyfora, ") + __inline_fora_string +
            " is a reserved word and expects a single argument "
            "string which defines an \"inline\" fora function",
            extent
            );
    }

//take a member name (e.g. 'x') and return the private form of the name (the
//name used by generated code) that refers to it. We use a space because it cannot
//conflict with the names produced by actual python code.
std::string publicDataMemberNameToPrivate(std::string name)
    {
    return "@" + name;
    }

ObjectDefinitionTerm noncapturingObjectMember(std::string name, Expression expr)
    {
    return
        ObjectDefinitionTerm::Anything(
            Function::Term(
                TuplePattern(
                    emptyTreeVec() +
                        TuplePatternElement::Normal(PatternWithName::Constant(CSTValue(Symbol("Member")))) +
                        TuplePatternElement::Normal(PatternWithName::Constant(CSTValue(Symbol(name))))
                    ),
                expr,
                Function::Empty()
                )
            );
    }

ClassDefinitionTerm
createInvalidNumberOfArgumentsClassDefinitionTerm(const std::string& name) {
    return ClassDefinitionTerm::ObjectTerm(
        ObjectDefinitionTerm::Member(
            Symbol(name),
            Expression::Throw(
                Expression::Constant(
                    CSTValue(name + "() takes no arguments; more than one given")
                    ),
                null()
                ),
            1
            )
        );
    }

class AssertOnlySimpleInitStatementsVisitor {
private:
    const std::string& mSelfName;
public:
    AssertOnlySimpleInitStatementsVisitor(const std::string& inSelfName) :
        mSelfName(inSelfName)
        {
        }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        if (expr.isYield())
            throw PythonToForaConversionError(
                "Yield is not supported in __init__ methods",
                expr.extent()
                );
        }

    void processDown(const PythonAstStatement& stmt, bool& outContinue)
        {
        if (stmt.isFunctionDef() or stmt.isClassDef())
            throw PythonToForaConversionError(
                "don't know how to handle function or class definitions in __init__ methods",
                stmt.extent()
                );

        if (stmt.isFunctionDef() or stmt.isReturn())
            throw PythonToForaConversionError(
                "Return statements are currently not supported in __init__ methods",
                stmt.extent()
                );
        
        if (stmt.isAssign()) {
            if (stmt.getAssign().targets().size() != 1)
                throw PythonToForaConversionError(
                    "don't know how to handle multiple assignment in __init__ methods",
                    stmt.extent()
                    );

            PythonAstExpr target = stmt.getAssign().targets()[0];

            if (target.isName()) {
                if (target.getName().id() == mSelfName) {
                    std::ostringstream oss;
                    oss << "don't know how to handle reassignments to self variable `" 
                        << mSelfName << "' in __init__ methods";
                    throw PythonToForaConversionError(
                        oss.str(), stmt.extent()
                        );
                    }
                }
            }
        }
};

class AssertNoStraySelfArgsInTransformedInitBodyVisitor {
private:
    const std::string& mSelfName;
public:
    AssertNoStraySelfArgsInTransformedInitBodyVisitor(
            const std::string& inSelfName
            ) :
        mSelfName(inSelfName)
    {
    }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        @match PythonAstExpr(expr)
            -| Name(id, ctx) ->> {
                if (id == mSelfName)
                    throw PythonToForaConversionError(
                        "in pyfora __init__ methods, the self arg can "
                        "only appear in setattr or getattr expressions.",
                        expr.extent()
                        );
                }
            -| Call(func, args, keywords, starargs, kwargs) ->> {
                // The ONLY place we allow 'self' to appear is as the first argument
                // to __init__ calls
                @match PythonAstExpr(func)
                    -| Attribute(value, attr, ctx) ->> {
                        outContinue = (attr != "__init__") || (args.size() == 0) ||
                            !args[0].isName() || (args[0].getName().id() != mSelfName);
                        }
                    -| _ ->> {}
                }
            -| _ ->> {}
            ;
        }
    };


template<class T>
void assertNoStraySelfArgsInTransformedInitBody(
        const T& t,
        const std::string& selfName
        )
    {
    AssertNoStraySelfArgsInTransformedInitBodyVisitor visitor(selfName);

    visit(t, visitor);
    }


class HasYieldFunctionBodyVisitor {
private:
    bool& mHasYield;
public:
    HasYieldFunctionBodyVisitor(
                bool& inHasYield
                ): 
            mHasYield(inHasYield)
        {
        }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        @match PythonAstExpr(expr)
            -| Yield(id, _) ->> {
                mHasYield = true;
                }
            -| Lambda() ->> { outContinue = false; }
            -| GeneratorExp() ->> { outContinue = false; }
            -| _ ->> {}
            ;
        }

    void processDown(const PythonAstStatement& expr, bool& outContinue)
        {
        @match PythonAstStatement(expr)
            -| FunctionDef() ->> {
                outContinue = false;
                }
            -| ClassDef() ->> {
                outContinue = false;
                }
            -| _ ->> {}
            ;
        }

};
        
template<class T>
bool hasYield(const T& value)
    {
    bool result = false;

    HasYieldFunctionBodyVisitor visitor(result);

    visit(value, visitor);

    return result;
    }


class ExtractVariablesReferencedInFunctionBodyVisitor {
private:
    std::set<std::string>& mReferencedVariables;
public:
    ExtractVariablesReferencedInFunctionBodyVisitor(
            std::set<std::string>& inReferencedVariables
            ): mReferencedVariables(inReferencedVariables)
        {
        }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        @match PythonAstExpr(expr)
            -| Name(id, _) ->> {
                mReferencedVariables.insert(id);
                }
            -| _ ->> {}
            ;
        }
};


class RewriteSelfSetAttrsTransformer {
private:
    SetOfStringPairs& mSelfSetItemMap;
    const std::set<std::string>& mReferencedVariables;
    const std::string& mSelfName;
public:
    RewriteSelfSetAttrsTransformer(
            SetOfStringPairs& inSelfSetItemMap,
            const std::set<std::string>& inReferencedVariables,
            const std::string& selfName
            ):
        mSelfSetItemMap(inSelfSetItemMap),
        mReferencedVariables(inReferencedVariables),
        mSelfName(selfName)
        {
        }

    template<class T>
    Nullable<T> processDown(const T& t, bool& b) const
        {
        return null();
        }

    template<class T>
    Nullable<T> processUp(const T& t) const
        {
        return null();
        }

    Nullable<PythonAstExpr> processDown(
            const PythonAstExpr& expr, bool& ioContinue
            ) const
        {
        @match PythonAstExpr(expr) 
            -| Attribute(value, attr, ctx) ->> {
                if (!value.isName() or 
                    value.getName().id() != mSelfName)
                    return null();

                std::string replacingName = getReplacingName(
                    attr
                    );

                mSelfSetItemMap.insert(
                    std::make_pair(
                        attr,
                        replacingName
                        )
                    );

                return null() << 
                    PythonAstExpr::Name(
                        replacingName,
                        ctx
                        );
                }
            -| _ ->> { return null(); }
        }

private:
    std::string getReplacingName(const std::string& attrName) const 
        {
        std::string tr = mSelfName + "_" + attrName;
        while (mReferencedVariables.find(tr) != mReferencedVariables.end())
            {
            tr = tr + "_";
            }
        return tr;
        }
};

Expression makeCreateInstanceCall(
        const std::string& membersTupleName,
        const std::string& className
        )
    {
    ImmutableTreeVector<ApplyArgument> arguments;

    arguments = arguments +
        ApplyArgument::Normal(
            null(),
            Expression::Constant(
                CSTValue(
                    Symbol("CreateInstance")
                    )
                )
            );

    arguments = arguments + ApplyArgument::Normal(
            null() << Symbol(MEMBERS_TUPLE_NAME),
            Expression::Variable(Symbol(membersTupleName))
            );

    return Expression::Apply(
        Expression::Variable(
            Symbol(className)
            ),
        arguments
        );
    }

void assertOnlySimpleInitStatements(
        const ImmutableTreeVector<PythonAstStatement>& functionBody,
        const std::string& inSelfName
        )
    {
    AssertOnlySimpleInitStatementsVisitor visitor(inSelfName);
    visit(functionBody, visitor);
    }

std::set<std::string> extractVariablesReferencedInFunctionBody(
        const ImmutableTreeVector<PythonAstStatement>& functionBody
        )
    {
    std::set<std::string> referencedVariables;
    ExtractVariablesReferencedInFunctionBodyVisitor visitor(referencedVariables);
    visit(functionBody, visitor);
    return referencedVariables;
    }

std::pair<ImmutableTreeVector<PythonAstStatement>, SetOfStringPairs>
rewriteSelfSetAttrs(const std::string& selfName,
                    const ImmutableTreeVector<PythonAstStatement>& body)
    {
    assertOnlySimpleInitStatements(body, selfName);

    std::set<std::string> referencedVariables = 
        extractVariablesReferencedInFunctionBody(
            body
            );

    SetOfStringPairs selfSetItemMap;

    RewriteSelfSetAttrsTransformer transformer(
        selfSetItemMap,
        referencedVariables,
        selfName
        );

    ImmutableTreeVector<PythonAstStatement> transformedBody = 
        transform(body, transformer);

    return std::make_pair(transformedBody, selfSetItemMap);
    }

void checkFunctionArgs(
        const PythonAstArguments& args,
        const SimpleParseRange& extent
        )
    {
    if (args.vararg().isValue())
        throw PythonToForaConversionError(
            "don't know how to handle *args yet",
            extent
            );
    if (args.kwarg().isValue())
        throw PythonToForaConversionError(
            "don't know how to handle **kwargs yet",
            extent
            );
    }

// we could probably move a more general 'slice' member function
// on PythonAstArguments, but this serves our purposes for now
PythonAstArguments dropFirstNormalArg(const PythonAstArguments& args)
    {
    if (args.defaults().size() < args.args().size())
        {
        return PythonAstArguments(
            args.args().slice(1),
            args.vararg(),
            args.kwarg(),
            args.defaults()
            );
        }

    lassert(args.defaults().size() == args.args().size());

    return PythonAstArguments(
        args.args().slice(1),
        args.vararg(),
        args.kwarg(),
        args.defaults().slice(1)
        );
    }

class MembersTupleTranformer {
private:
    const std::unordered_map<std::string, std::string>& mNewNamesToOriginal;
    const std::string& mSelfName;
    const std::string& mMembersTupleName;
public:
    MembersTupleTranformer(
            const std::unordered_map<std::string, std::string>& newNamesToOriginal,
            const std::string& selfName,
            const std::string& membersTupleName
            ):
        mNewNamesToOriginal(newNamesToOriginal),
        mSelfName(selfName),
        mMembersTupleName(membersTupleName)
        {
        }

    template<class T>
    Nullable<T> processDown(const T& t, bool& b) const
        {
        return null();
        }

    template<class T>
    Nullable<T> processUp(const T& t) const
        {
        return null();
        }

    Nullable<Expression> processUp(const Expression& expr) const
        {
        @match Expression(expr)
            -| Assign (toAssign, value) ->> {
                Nullable<Expression> memberTupleAssignment = processAssign(toAssign, value);
                return memberTupleAssignment.isValue() ?
                    null() << Expression::Sequence(expr, *memberTupleAssignment) :
                    null();
                }
            -| Call (agent, arguments) ->> {
                if (!isFirstArgSelf(arguments) || !isInitMember(agent))
                    return null();

                return null() << Expression::Assign(
                        PatternWithName::Anything(null() << Symbol(mMembersTupleName)),
                        Expression::CreateTuple(emptyTreeVec() +
                            ApplyArgument::TupleCall(
                                Expression::Member(
                                    Expression::Call(
                                        agent.getMember().agent(),
                                        arguments.slice(1)
                                        ),
                                    Symbol(MEMBERS_TUPLE_NAME), 1
                                    )
                                ) +
                            ApplyArgument::TupleCall(
                                Expression::Variable(Symbol(mMembersTupleName))
                                )
                            )
                        );
                }

            -| _ ->> { return null(); }
        }
private:
    Nullable<Expression> processAssign(const PatternWithName& toAssign,
                                       const Expression& value) const
        {
        ImmutableTreeSet<Symbol> selfAttributes;

        @match Pattern(toAssign.pattern())
            -| Anything() ->> {
                auto name = toAssign.name();
                lassert(name.isValue());
                if (mNewNamesToOriginal.find(name->toString()) != mNewNamesToOriginal.end())
                    selfAttributes = selfAttributes + *name;
                }
            -| ExpressionMatch(expr, pattern) ->> {
                if (isTupleAssign(expr))
                    {
                    for (const TuplePatternElement& el: pattern.matchers())
                        {
                        lassert_dump(el.isNormal(), "varargs not allowed in assignments");
                        auto symbol = el.getNormal().match().name();
                        if (symbol.isValue() &&
                                mNewNamesToOriginal.find(symbol->toString()) != mNewNamesToOriginal.end())
                            selfAttributes = selfAttributes + *symbol;
                        }
                    }
                }
            -| _ ->> {
                LOG_ERROR << "Unexpected Pattern type: " << toAssign.pattern();
                }

        if (selfAttributes.size() == 0)
            return null();

        ImmutableTreeVector<ApplyArgument> assignValues = mapITV(
                selfAttributes,
                [&](Symbol newName) {
                    return ApplyArgument::Normal(
                        null() << Symbol(mNewNamesToOriginal.at(newName.toString())),
                        Expression::Variable(newName)
                        );
                });
        assignValues = assignValues + ApplyArgument::TupleCall(
                Expression::Variable(Symbol(mMembersTupleName))
                );
        return null() << Expression::Assign(
                            PatternWithName::Anything(null() << Symbol(mMembersTupleName)),
                            Expression::CreateTuple(assignValues)
                            );
        }

    bool isFirstArgSelf(const ImmutableTreeVector<ApplyArgument> arguments) const
        {
        if (arguments.size() == 0)
            return false;

        @match ApplyArgument(arguments[0])
            -| Normal (name, expr) ->> {
                return expr.isVariable() && expr.getVariable().variable().toString() == mSelfName;
                }
            -| _ ->> { return false; }
        }

    bool isInitMember(const Expression& agent) const
        {
        @match Expression(agent)
            -| Member (agent, member, depth) ->> {
                return member.toString() == "__init__";
                }
            -| _ ->> { return false; }
        }

    bool isTupleAssign(const Expression& expr) const
        {
        @match Expression(expr)
            -| Constant(val) ->> {
                return val.type().isTuple() &&
                    *val.tupleGetSize() == 2 &&
                    *val.tupleGetItem(0) == CSTValue::Tag(Symbol("TupleAssign"));
                }
            -| _ ->> { return false; }
        }
};


Expression populateMembersTuple(const Expression& expr,
                                const SetOfStringPairs& selfSetItemMap,
                                const std::string& selfName,
                                const std::string& membersTupleName)
    {
    if (selfSetItemMap.size() == 0)
        return expr;

    std::unordered_map<std::string, std::string> newNamesToOriginal;
    for (const auto& p: selfSetItemMap)
          newNamesToOriginal[p.second] = p.first;

    MembersTupleTranformer transformer(
            newNamesToOriginal,
            selfName,
            membersTupleName);
    return transform(expr, transformer);
    }

} // anonymous namespace

namespace Fora {

ImplValContainer getModuleMember(ImplValContainer module, std::string memberName)
    {
    FunctionStage1::Simulation simulation(100);

    FunctionStage1::ExpressionEvaluationResult result = 
        simulation.evaluateApply(
            emptyTreeVec() + 
                module + 
                ImplValContainerUtilities::createSymbol(Symbol("Member")) + 
                ImplValContainerUtilities::createSymbol(Symbol(memberName))
            );

    lassert(result.isResult());
    
    return result.getResult().val();
    }



PythonAstConverter::PythonAstConverter(
            PolymorphicSharedPtr<PythonConstantConverter> constantConverter,
            PolymorphicSharedPtr<PythonListConverter> listConverter,
            PolymorphicSharedPtr<PythonTupleConverter> tupleConverter,
            PolymorphicSharedPtr<PythonDictConverter> dictConverter,
            ImplValContainer pyforaBuiltins,
            const ImmutableTreeMap<
                Symbol,
                pair<ImplValContainer, Nullable<Symbol>>
                >& builtinMemberMapping
            )
        : mConstantConverter(constantConverter),
          mPythonListConverter(listConverter),
          mPythonTupleConverter(tupleConverter),
          mPythonDictConverter(dictConverter),
          mPyforaBuiltins(pyforaBuiltins),
          mBuiltinMemberMapping(builtinMemberMapping)
    {
    mPyBoundMethod = getModuleMember(pyforaBuiltins, "PyBoundMethod");

    mPyObjectBaseMixin = getModuleMember(pyforaBuiltins, "PyObjectBase");
    lassert_dump(mPyObjectBaseMixin.type().isClass() || mPyObjectBaseMixin.type().isNothing(),
                 "pyObjectBaseMixin must be 'noting' or an object");

    mPyGeneratorFactory = getModuleMember(pyforaBuiltins, "Generator");

    mPySliceFactory = getModuleMember(pyforaBuiltins, "Slice");

    mPyListType = getModuleMember(pyforaBuiltins, "ListType");

    mTypeError = getModuleMember(pyforaBuiltins, "TypeError");

    mPyString = getModuleMember(pyforaBuiltins, "PyString");

    mPyDictType = getModuleMember(pyforaBuiltins, "DictType");

    mAssertionError = getModuleMember(pyforaBuiltins, "AssertionError");
    }

PolymorphicSharedPtr<PythonConstantConverter> PythonAstConverter::constantConverter() const
    {
    return mConstantConverter;
    }

Function PythonAstConverter::invalidCallHandler(
        const std::string& functionName,
        const TuplePattern& patternForFunction
        ) const
    {
    uint32_t nNormalArgs = 0;
    uint32_t nDefaultArgs = 0;
    
    for (const auto& tuplePatternElement: patternForFunction.matchers())
        {
        @match TuplePatternElement(tuplePatternElement) 
            -|  Normal(_, _, defaultValueOrNull) ->> {
                nNormalArgs++;
                if (defaultValueOrNull.isValue()) 
                    nDefaultArgs++;
                }
            -|  VarArgs(_) ->> {
                // the matchers for the original function will handle this, 
                // and we'll never need to handle it here
                return Function::Empty()
                }
            ;
        }

    Symbol argsSymbol = Symbol("args");
    Expression argsVariable = Expression::Variable(argsSymbol);
    Expression rawErrorString;

    if (nDefaultArgs > 0)
        rawErrorString = invalidCallHandlerWithDefaultArgsRawErrorString(
            nNormalArgs,
            nDefaultArgs,
            functionName,
            argsVariable
            );
    else
        rawErrorString = invalidCallHandlerNoDefaultArgsRawErrorString(
            nNormalArgs,
            functionName,
            argsVariable
            );

    Expression pyStringifiedErrorString =
        Expression::Call(
            Expression::Constant(
                mPyString
                ),
            emptyTreeVec() + rawErrorString.normalApplyArg()
            );

    Expression functionBody = 
        Expression::Throw(
            Expression::Call(
                Expression::Constant(
                    mTypeError
                    ),
                emptyTreeVec() +
                    pyStringifiedErrorString.normalApplyArg()
                ),
            null()
            );

    return Function::Term(
        TuplePattern(
            emptyTreeVec() +
            TuplePatternElement::VarArgs(
                null() << argsSymbol
                )
            ),
        functionBody,
        Function::Empty()
        );
    }

Expression PythonAstConverter::invalidCallHandlerWithDefaultArgsRawErrorString(
        uint32_t nNormalArgs,
        uint32_t nDefaultArgs,
        const std::string& functionName,
        const Expression& argsVariable
        ) const
    {
    uint32_t nNonDefaultArgs = nNormalArgs - nDefaultArgs;

    std::ostringstream oss;
    oss << functionName << "() takes at most " << nNormalArgs 
        << (nNormalArgs == 1 ? " argument (" : " arguments (")
        ;

    Expression tooManyCallArgsPrefix = Expression::Constant(CSTValue(oss.str()));

    oss.str("");
    oss.clear();
    oss << functionName << "() takes at least " << nNonDefaultArgs 
        << (nNonDefaultArgs == 1 ? " argument (" : " arguments (")
        ;

    Expression tooFewCallArgsPrefix = Expression::Constant(CSTValue(oss.str()));

    Symbol nCallArgsGivenSymbol = Symbol("nCallArgsGiven");
    Expression nCallArgsGivenString = 
        Expression::Call(
            Expression::Constant(
                CSTValue(JOV::OfType(Type::String()))
                ),
            emptyTreeVec() +
                Expression::Variable(nCallArgsGivenSymbol).normalApplyArg()
        );

    Expression suffix = 
        Expression::BinaryOperator(
            nCallArgsGivenString,
            Symbol("+"),
            Expression::Constant(CSTValue(" given)"))
            );

    return Expression::Let(
        nCallArgsGivenSymbol,
        Expression::Call(
            Expression::Constant(
                CSTValue(Symbol("size"))
                ),
            emptyTreeVec() +
                argsVariable.normalApplyArg()
            ),
        Expression::Branch(
            Expression::BinaryOperator(
                Expression::Variable(nCallArgsGivenSymbol),
                Symbol("<"),
                Expression::Constant(CSTValue(nNonDefaultArgs))
                ),
            Expression::BinaryOperator(
                tooFewCallArgsPrefix,
                Symbol("+"),
                suffix
                ),
            null() << Expression::BinaryOperator(
                tooManyCallArgsPrefix,
                Symbol("+"),
                suffix
                )
            )
        );
    }

Expression PythonAstConverter::invalidCallHandlerNoDefaultArgsRawErrorString(
        uint32_t nNormalArgs,
        const std::string& functionName,
        const Expression& argsVariable
        ) const
    {
    std::ostringstream oss;
    oss << functionName << "() takes ";

    if (nNormalArgs == 0) {
        oss << "no arguments";
        }
    else {
        oss << "exactly " << nNormalArgs << " argument"
            << (nNormalArgs == 1 ? "" : "s")
        ;
        }
    oss << " (";

    Expression prefixString = Expression::Constant(CSTValue(oss.str()));

    Expression nCallArgsGivenString =
        Expression::Call(
            Expression::Constant(
                CSTValue(JOV::OfType(Type::String()))
                ),
            emptyTreeVec() +
                Expression::Call(
                    Expression::Constant(
                        CSTValue(Symbol("size"))
                        ),
                    emptyTreeVec() +
                        argsVariable.normalApplyArg()
                    ).normalApplyArg()
        );

    Expression suffixString = Expression::Constant(CSTValue(" given)"));

    return
        Expression::BinaryOperator(
            prefixString,
            Symbol("+"),
            Expression::BinaryOperator(
                nCallArgsGivenString,
                Symbol("+"),
                suffixString
                )
            );
    }


/*
We've got an ITV<ClassDefinitionTerm> here because certain python class body statements produce
more than one Fora ClassDefinitionTerm, for example __init__ gives a Constructor and (possibly)
DataMembers.
*/
ImmutableTreeVector<ClassDefinitionTerm>
PythonAstConverter::convertPythonClassBodyStatementToForaClassDefinitionTerms(
        const PythonAstStatement& statement,
        const std::string& className
        ) const
    {
    @match PythonAstStatement(statement)
        -| FunctionDef(_, _, _, _) ->> {
            return convertPythonClassBodyFunctionDefToForaClassDefinitionTerms(
                statement.getFunctionDef(),
                statement.extent(),
                className
                );
            }
        -| Pass() ->> {
            return emptyTreeVec();
            }
        -| Expr(Str(s)) ->> {
            ///This swallows doc strings
            return emptyTreeVec();
            }
        -| _ ->> {
            std::ostringstream oss;
            oss << PYFORA_CONVERSION_ERROR_MESSAGE;
            throw PythonToForaConversionError(
                oss.str(),
                statement.extent()
                );
            }
    }

Expression PythonAstConverter::initializeUnboundVariablesForFunction(
        const TuplePattern& pattern,
        const Expression& inputFunctionBody
        ) const
    {
    Expression functionBody = inputFunctionBody;
    
    //look at all the variables we assign to at the root scope. If they are not bound
    //then they are 'free', but also assigned. We don't allow globals, so they'll all need
    //null let bindings
    ImmutableTreeSet<Symbol> bound = pattern.boundVariables();
    ImmutableTreeSet<Symbol> assigned = functionBody.assignedVariables();
    ImmutableTreeSet<Symbol> needingBindings = assigned - bound;

    for (auto s: needingBindings)
        functionBody = Expression::Let(
            s, 
            Expression::Constant(CSTValue(Symbol("PyforaUninitializedVariable"))),
            rebindFreeAs(functionBody, emptyTreeMap() + s + checkVariableValidityExpression(s))
            );

    return functionBody;
    }

// should only be called from convertPythonClassBodyFunctionDefToForaClassDefinitionTerm
// which does some preliminary verification 
ImmutableTreeVector<ClassDefinitionTerm> 
PythonAstConverter::convertPythonInitDefToForaClassDefinitionTerms(
        const PythonAstStatement_FunctionDefType& functionDef,
        const std::string& className
        ) const
    {
    PythonAstArguments args = functionDef.args();

    TuplePatternElement selfArg = TuplePatternElement::Normal(
        null(),
        convertPythonAstExpressionToPattern(args.args()[0]),
        null()
        );

    std::string selfName;
        {
        lassert(selfArg.isNormal());

        auto nullableName = selfArg.getNormal().match().name();

        lassert(nullableName.isValue());
        selfName = nullableName->toString();
        }

    ImmutableTreeVector<TuplePatternElement> foraArgs = 
        computeForaArgs(dropFirstNormalArg(args));

    std::pair<ImmutableTreeVector<PythonAstStatement>, SetOfStringPairs>
        transformedBodyAndSelfSetItemMap = rewriteSelfSetAttrs(
            selfName,
            functionDef.body()
            );

    assertNoStraySelfArgsInTransformedInitBody(
        transformedBodyAndSelfSetItemMap.first,
        selfName
        );

    TuplePattern pattern = TuplePattern(foraArgs);
    Expression functionBody = 
        convertPythonAstStatementsToExpression(
            transformedBodyAndSelfSetItemMap.first
            );

    functionBody = populateMembersTuple(
            functionBody,
            transformedBodyAndSelfSetItemMap.second,
            selfName,
            "@members");


    Expression createInstanceCall = makeCreateInstanceCall("@members", className);

    functionBody = Expression::Let(
            emptyTreeVec() + std::make_pair(
                PatternWithName::Anything(null() << Symbol("@members")),
                Expression::CreateTuple(ImmutableTreeVector<ApplyArgument>())
                ),
            Expression::Sequence(functionBody, createInstanceCall)
            );

    functionBody = initializeUnboundVariablesForFunction(pattern, functionBody);

    ImmutableTreeVector<ClassDefinitionTerm> tr = emptyTreeVec() +
        ClassDefinitionTerm::DataMember(Symbol(MEMBERS_TUPLE_NAME)) +
        ClassDefinitionTerm::ObjectTerm(
            noncapturingObjectMember(
                MEMBERS_TUPLE_NAME,
                Expression::Variable(Symbol(MEMBERS_TUPLE_NAME))
                )
            );

    for (const auto& p: transformedBodyAndSelfSetItemMap.second)
        {
        tr = tr + ClassDefinitionTerm::ObjectTerm(
            noncapturingObjectMember(
                p.first,
                Expression::Member(
                    Expression::Variable(Symbol(MEMBERS_TUPLE_NAME)),
                    Symbol(p.first),
                    1)
                )
            );
        }

    return tr + ClassDefinitionTerm::Constructor(
        Function::Term(
            pattern,
            functionBody,
            Function::Empty()
            )
        );
    }




ImmutableTreeVector<ClassDefinitionTerm>
PythonAstConverter::convertPythonClassBodyFunctionDefToForaClassDefinitionTerms(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent,
        const std::string& className
        ) const
    {
    PythonAstArguments args = functionDef.args();

    checkFunctionArgs(args, extent);

    const std::string& functionName = functionDef.name();

    ImmutableTreeVector<PythonAstExpr> decoratorList = functionDef.decorator_list();

    //check if it's @staticmethod or @property
    ImmutableTreeVector<PythonAstStatement> body = functionDef.body();
    if (decoratorList.size() > 0) {
        if (decoratorList.size() == 1
            and decoratorList[0].isName())
            {
            const std::string& decoratorName = decoratorList[0].getName().id();

            if (decoratorName == "staticmethod") {
                return
                    convertPythonClassBodyStaticMethodFunctionDefToForaClassDefinitionTerms(
                        functionDef,
                        extent
                        );
                }
            else if (decoratorName == "property") {
                return emptyTreeVec() +
                    convertPythonClassBodyPropertyToForaClassDefinitionTerm(
                        functionDef,
                        extent
                        );
                }
            }

        throw PythonToForaConversionError(
            "don't know how to convert decorator lists for functions, "
            "besides \"staticmethod\" and \"property\", right now",
            extent
            );
        }

    if (args.args().size() == 0)
        {
        return emptyTreeVec() + 
            createInvalidNumberOfArgumentsClassDefinitionTerm(
                functionDef.name()
                );
        }

    if (functionName == "__init__")
        {
        // should assert that there are no decorators
        if (decoratorList.size() > 0)
            throw PythonToForaConversionError(
                "don't know how to convert `__init__` methods with decorators right now",
                extent
                );

        return convertPythonInitDefToForaClassDefinitionTerms(functionDef, className);
        }

    Function function = 
        convertFunctionDefToForaFunction(
            functionDef,
            extent
            );

    //expose the function member as a ...(`Member, `f) { fun() {...} }
    //so that we don't capture 'f' in the class binding
    auto res = emptyTreeVec() + ClassDefinitionTerm::ObjectTerm(
        noncapturingObjectMember(
            functionName,
            Expression::Call(
                Expression::Constant(mPyBoundMethod),
                emptyTreeVec() + 
                    Expression::Variable(Symbol("@self")).normalApplyArg() + 
                    Expression::CreateFunction(
                        functionName,
                        function,
                        CSTValue()
                        ).normalApplyArg() + 
                    Expression::Constant(CSTValue(Symbol(functionName))).normalApplyArg()
                )
            )
        );
    
    return res;
    }

namespace {
    Expression constantExpressionForImplVal(const ImplValContainer& val)
        {
        return Expression::Constant(CSTValue(val));
        }
    }

Expression PythonAstConverter::convertPythonAstLambdaToFora(
                    const PythonAstArguments& arguments, 
                    const PythonAstExpr& body,
                    const SimpleParseRange& extent
                    ) const
    {
    return convertPythonAstFunctionDefToFora(
        PythonAstStatement_FunctionDefType(
            "<lambda>",
            arguments,
            emptyTreeVec() + PythonAstStatement::Return(null() << body),
            emptyTreeVec()
            ),
        extent
        );
    }

Expression PythonAstConverter::convertNullableExpressionToExpression(
        const Nullable<PythonAstExpr>& expr
        ) const
    {
    if (expr.isNull())
        return Expression::Constant(mConstantConverter->noneValue());

    return convertPythonAstExpressionToFora(*expr);
    }

Expression PythonAstConverter::convertPythonAstSliceToExpression(
        const PythonAstSlice& slice,
        const SimpleParseRange& extent
        ) const
    {
    @match PythonAstSlice(slice)
        -| Ellipsis() ->> {
            // not dealing with this just yet. we'll get to it
            std::ostringstream oss;
            oss << PYFORA_CONVERSION_ERROR_MESSAGE;
            throw PythonToForaConversionError(
                oss.str(),
                extent
                );
            }
        -| Slice(start, stop, step) ->> {
            return
                Expression::Apply(
                    Expression::Constant(
                        CSTValue(mPySliceFactory)
                        ),
                    emptyTreeVec() + 
                        ApplyArgument::Normal(
                            Expression::Constant(
                                CSTValue(Symbol("Call"))
                                )
                            ) +
                        ApplyArgument::Normal(
                            convertNullableExpressionToExpression(start)
                            ) +
                        ApplyArgument::Normal(
                            convertNullableExpressionToExpression(stop)
                            ) +
                        ApplyArgument::Normal(
                            convertNullableExpressionToExpression(step)
                            )
                    );
            }
        -| ExtSlice(slices) ->> {
            ImmutableTreeVector<ApplyArgument> tupleArgs = mapITV(
                slices,
                [this, extent](PythonAstSlice slice) {
                    return ApplyArgument::Normal(
                        convertPythonAstSliceToExpression(slice, extent)
                        );
                    }
                );

            return mPythonTupleConverter->createTupleExpression(
                Expression::CreateTuple(tupleArgs)
                );
            }
        -| Index(value) ->> {
            return convertPythonAstExpressionToFora(value);
            }
        ;
    }

Expression PythonAstConverter::wrapExpressionInPyContinueCheck(Expression e) const
    {
    return Expression::Try(
        e,
        Function::Term(
            TuplePattern(
                emptyTreeVec() + 
                    TuplePatternElement::Normal(
                        PatternWithName::Constant(CSTValue(Symbol("PyContinue")))
                        )
                ),
            Expression(),
            Function::Empty()
            ),
        null(),
        false
        );
    }

Expression PythonAstConverter::convertPythonAstExpressionToFora_inner(const PythonAstExpr& expr) const
    {
    @match PythonAstExpr(expr)
        -| Str(stdString) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertString(stdString)
                );
            }
        -| Num(Int(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertInt(value)
                );
            }
        -| Num(Long(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertLong(value)
                );
            }
        -| Num(Boolean(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertBoolean(value)
                );
            }
        -| Num(None()) ->> {
             return constantExpressionForImplVal(
                constantConverter()->noneValue()
                );
             }
        -| Num(Float(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertFloat(value)
                );
            }
        -| BoolOp(And(), exprs) ->> {
            lassert(exprs.size() > 0)

            Expression res = convertPythonAstExpressionToFora(exprs.back());

            for (long k = exprs.size() - 2; k >= 0; k--)
                {
                Symbol conditional("@conditional");

                res = Expression::Let(
                    conditional, 
                    convertPythonAstExpressionToFora(exprs[k]), 
                    Expression::Branch(
                        convertExpressionToForaBoolean(
                            Expression::Variable(conditional)
                            ),
                        res,
                        null() << Expression::Variable(conditional)
                        )
                    );
                }

            return res;
            }
        -| BoolOp(Or(), exprs) ->> {
            lassert(exprs.size() > 0)

            Expression res = convertPythonAstExpressionToFora(exprs.back());

            for (long k = exprs.size() - 2; k >= 0; k--)
                {
                Symbol conditional("@conditional");

                res = Expression::Let(
                    conditional, 
                    convertPythonAstExpressionToFora(exprs[k]), 
                    Expression::Branch(
                        convertExpressionToForaBoolean(
                            Expression::Variable(conditional)
                            ),
                        Expression::Variable(conditional),
                        null() << res
                        )
                    );
                }
            
            return res;
            }
        -| Attribute(value, attribute, ctx) ->> {
            Expression agent = convertPythonAstExpressionToFora(value);

            return agent.member(Symbol(attribute));
            }
        -| Subscript(value, slice, ctx) ->> {
            Expression valueGetItemMemberFunction = 
                Expression::Member(
                    convertPythonAstExpressionToFora(value),
                    Symbol("__getitem__"),
                    1
                    );

            auto sliceArg =
                ApplyArgument::Normal(
                    convertPythonAstSliceToExpression(slice, expr.extent())
                    );

            return Expression::Call(
                valueGetItemMemberFunction,
                emptyTreeVec() + sliceArg
                );
            }
        -| GeneratorExp(expr, generators) ->> {
            lassert(generators.size());

            /************************************
            generator-expressions get transformed as follows: 
            
                (expr for pat in generator if filterExpr)
            
            becomes

                generator.__pyfora_generator__().filter(lambda pat: filterExpr).map(lambda pat: expr)

            with nested iterators, we have
                
                (expr1 for pat1 in generator if filtExpr for pat2 in sub_generator if filtExpr2) 

            becoming

                generator
                    .__pyfora_generator__()
                    .filter(lambda pat1: filtExpr)
                    .nest(lambda pat1: 
                        sub_generator
                            .__pyfora_generator__()
                            .filter(lambda pat2: filtExpr2)
                            .map(lambda pat2: expr)
                        )

            ***********************************/
            
            Nullable<Expression> accumulator;

            for (long genIx = generators.size() - 1; genIx >= 0; genIx--)
                {
                Expression generator = 
                    convertPythonAstExpressionToFora(generators[genIx].iter())
                        .member(Symbol("__pyfora_generator__"))();

                for (auto c: generators[genIx].conditions())
                    generator = generator.member(Symbol("filter"))(
                        convertPythonAstExpressionToFora(
                            PythonAstExpr::Lambda(
                                PythonAstArguments(
                                    emptyTreeVec() + generators[genIx].target(),
                                    null(),
                                    null(),
                                    emptyTreeVec()
                                    ),
                                c
                                )
                            )
                        );

                //the first time in the loop, we are calculating the 
                if (!accumulator)
                    accumulator = generator.member(Symbol("map"))(
                        convertPythonAstExpressionToFora(
                            PythonAstExpr::Lambda(
                                PythonAstArguments(
                                    emptyTreeVec() + generators[genIx].target(),
                                    null(),
                                    null(),
                                    emptyTreeVec()
                                    ),
                                expr
                                )
                            )
                        );
                else
                    accumulator = generator.member(Symbol("nest"))(
                        createObjectImplementingCallOperatorForFunction(
                            Function::Term(
                                TuplePattern(
                                    emptyTreeVec() + 
                                        TuplePatternElement::Normal(
                                            convertPythonAstExpressionToPattern(generators[genIx].target())
                                            )
                                    ),
                                *accumulator,
                                Function::Empty()
                                ),
                            "<lambda>",
                            null()
                            )
                        );
                }
            
            return *accumulator;
            }
        -| ListComp(elt, generators) ->> {
            ImmutableTreeSet<Symbol> assigned;
            for (auto gen: generators)
                assigned = assigned + convertPythonAstExpressionToPattern(
                    gen.target()
                    ).boundVariables();

            auto res = 
                Expression::Constant(mPyListType)(
                    convertPythonAstExpressionToFora(
                        PythonAstExpr::GeneratorExp(elt, generators)
                        )
                    );

            for (auto var: assigned)
                res = Expression::Sequence(
                    Expression::Assign(
                        PatternWithName::Anything(null() << var),
                        Expression::Constant(CSTValue(Symbol("PyforaInvalidVariable")))
                        ),
                    res
                    );

            return res;
            }
        -| List(elts) ->> {
            return mPythonListConverter->convertPyList(
                expr.getList(),
                boost::bind(
                    &PythonAstConverter::convertPythonAstExpressionToFora,
                    this, 
                    _1
                    )
                );
            }
        -| Dict(elts) ->> {
            return mPythonDictConverter->convertPyDict(
                expr.getDict(),
                boost::bind(
                    &PythonAstConverter::convertPythonAstExpressionToFora,
                    this, 
                    _1
                    )
                );
            }
        -| DictComp(key, value, generators) ->> {
            PythonAstExpr pyUpdateSequence = 
                PythonAstExpr::ListComp(
                    PythonAstExpr::Tuple(
                        emptyTreeVec() + key + value,
                        PythonAstExprContext::Load()
                        ),
                    generators
                    );

            Expression foraUpdateSequence =
                convertPythonAstExpressionToFora(
                    pyUpdateSequence
                    );
        
            return Expression::Call(
                Expression::Constant(
                    mPyDictType
                    ),
                emptyTreeVec() +
                foraUpdateSequence.normalApplyArg()
                );
            }
        -| Tuple(elts) ->> {
            return mPythonTupleConverter->convertPyTuple(
                expr.getTuple(),
                boost::bind(
                    &PythonAstConverter::convertPythonAstExpressionToFora,
                    this,
                    _1
                    )
                );
            }
        -| UnaryOp(op, rhs) ->> {
            Symbol opAsSymbol;
            
            @match PythonAstUnaryOp(op)
                -| Invert() ->> { opAsSymbol = Symbol("~"); }
                -| Not() ->> { opAsSymbol = Symbol("!"); }
                -| UAdd() ->> { opAsSymbol = Symbol("+"); }
                -| USub() ->> { opAsSymbol = Symbol("-"); }
                ;

            return Expression::LeftOperator(
                opAsSymbol,
                convertPythonAstExpressionToFora(rhs)
                );
            }
        -| BinOp(lhs, Add(), List(Leaf(elt, Empty()))) ->> {
            Expression convertedLhs = convertPythonAstExpressionToFora(lhs);
            Expression convertedElt = convertPythonAstExpressionToFora(elt);

            return mPythonListConverter->concatSingleEltVectorExpr(
                convertedLhs, convertedElt
                );
            }
        -| BinOp(lhs, op, rhs) ->> {
            Symbol opAsSymbol;
            
            @match PythonAstBinaryOp(op)
                -| Add() ->> { opAsSymbol = Symbol("+"); }
                -| Sub() ->> { opAsSymbol = Symbol("-"); }
                -| Mult() ->> { opAsSymbol = Symbol("*"); }
                -| Div() ->> { opAsSymbol = Symbol("/"); }
                -| Mod() ->> { opAsSymbol = Symbol("%"); }
                -| Pow() ->> { opAsSymbol = Symbol("**"); }
                -| LShift() ->> { opAsSymbol = Symbol("<<"); }
                -| RShift() ->> { opAsSymbol = Symbol(">>"); }
                -| BitOr() ->> { opAsSymbol = Symbol("|"); }
                -| BitXor() ->> { opAsSymbol = Symbol("^"); }
                -| BitAnd() ->> { opAsSymbol = Symbol("&"); }
                -| FloorDiv() ->> { opAsSymbol = Symbol("//"); }
                ;

            return Expression::BinaryOperator(
                convertPythonAstExpressionToFora(lhs),
                opAsSymbol,
                convertPythonAstExpressionToFora(rhs)
                );
            }
        -| Lambda(arguments, body) ->> {
            return convertPythonAstLambdaToFora(arguments, body, expr.extent());
            }
        -| IfExp(cond, ifTrue, ifFalse) ->> {
            return Expression::Branch(
                convertPythonAstExpressionToForaBoolean(cond),
                convertPythonAstExpressionToFora(ifTrue),
                null() << convertPythonAstExpressionToFora(ifFalse)
                );
            }
        -| Repr(expr) ->> {
            return Expression::Call(
                Expression::Constant(CSTValue(Symbol("ParsableRepresentation"))),
                emptyTreeVec() + 
                    ApplyArgument::Normal(
                        convertPythonAstExpressionToFora(expr)
                        )
                );
            }
        -| Compare(expr, comparisons, comparisonExprs) ->> {
            if (comparisons.size() != comparisonExprs.size())
                throw PythonToForaConversionError(
                    "valid python should have an equal number of comparison operators and expressions",
                    expr.extent()
                    );

            if (comparisons.size() != 1)
                throw PythonToForaConversionError(
                    "don't know how to convert chained comparisons yet.",
                    expr.extent()
                    );

            Expression curExpr = convertPythonAstExpressionToFora(expr);
            Expression result;

            for (long k = 0; k < comparisons.size(); k++)
                {
                Expression curRhs = convertPythonAstExpressionToFora(comparisonExprs[k]);

                Expression toAdd;

                @match PythonAstComparisonOp(comparisons[k])
                    -| Eq() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("=="), curRhs); }
                    -| NotEq() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("!="), curRhs); }
                    -| Lt() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("<"), curRhs); }
                    -| LtE() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("<="), curRhs); }
                    -| Gt() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol(">"), curRhs); }
                    -| GtE() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol(">="), curRhs); }
                    -| Is() ->> { 
                        toAdd = Expression::Branch(
                            Expression::Is(curExpr, curRhs), 
                            Expression::Constant(mConstantConverter->convertBoolean(true)), 
                            null() << Expression::Constant(mConstantConverter->convertBoolean(false))
                            ); 
                        }
                    -| IsNot() ->> {
                        toAdd = Expression::Branch(
                            Expression::IsNot(curExpr, curRhs), 
                            Expression::Constant(mConstantConverter->convertBoolean(true)), 
                            null() << Expression::Constant(mConstantConverter->convertBoolean(false))
                            ); 
                        }
                    -| In() ->> { toAdd = Expression::In(curExpr, curRhs); }
                    -| NotIn() ->> { 
                        toAdd = Expression::Branch(
                            convertExpressionToForaBoolean(
                                Expression::In(curExpr, curRhs)
                                ),
                            Expression::Constant(
                                mConstantConverter->convertBoolean(false)
                                ),
                            null() << Expression::Constant(
                                mConstantConverter->convertBoolean(true)
                                )
                            );
                        }
                    ;

                if (k == 0)
                    result = toAdd;
                else
                    result = Expression::And(result, toAdd);
                }

            return result;
            }
        -| Yield(e) ->> {
            return
                Expression::Continuation(
                    Function::Term(
                        TuplePattern(emptyTreeVec() +
                            TuplePatternElement::Normal(
                                PatternWithName::Anything(null() << Symbol("@continuation"))
                                )
                            ),
                        Expression::Return(
                            Expression::CreateTuple(
                                emptyTreeVec() + 
                                    ApplyArgument::Normal(
                                        e ? convertPythonAstExpressionToFora(*e) : Expression()
                                        ) +
                                    ApplyArgument::Normal(Expression::Variable(Symbol("@continuation")))
                                )
                            ),
                    Function::Empty()
                    )
                );
            }
        -| Call(func, args, kwds, starArgs, kwargs) ->> {
            if (func.isName() and func.getName().id() == __inline_fora_string)
                return convertInlineFora(expr.getCall(), expr.extent());

            if (starArgs.isValue())
                throw PythonToForaConversionError(
                    "don't know how to convert starArgs just yet.",
                    expr.extent()
                    );

            if (kwargs.isValue())
                throw PythonToForaConversionError(
                    "don't know how to convert kwargs just yet.",
                    expr.extent()
                    );

            if (kwds.size() > 0)
                throw PythonToForaConversionError(
                    "don't know how to convert keywords just yet.",
                    expr.extent()
                    );

            return Expression::Call(
                convertPythonAstExpressionToFora(func),
                mapITV(args, [this](PythonAstExpr expr) {
                    return ApplyArgument::Normal(
                        convertPythonAstExpressionToFora(expr)
                        );
                    })
                );
            }
        -| Name(identifier, Load()) ->> {
            //when loading variables, we need to check whether they are specific symbols
            //that we use to denote states like 'uninitialized' or 'invalid'. If so, we defer
            //to a member of the PyObjectBase to figure out what to do
            assertValidNameIdentifier(identifier, expr.extent());

            return Expression::Variable(Symbol(identifier));
            }
        -| _ ->> {
            }

    std::ostringstream oss;
    oss << PYFORA_CONVERSION_ERROR_MESSAGE;
    throw PythonToForaConversionError(
        oss.str(),
        expr.extent()
        );
    }

Expression PythonAstConverter::convertInlineFora(
        const PythonAstExpr_CallType& callExpr,
        const SimpleParseRange& extent
        ) const
    {
    if (callExpr.keywords().size() > 0)
        throw PythonToForaConversionError(
            "__inline_fora accepts no keyword args",
            extent
            );

    if (callExpr.starargs().isValue() > 0)
        throw PythonToForaConversionError(
            "__inline_fora accepts no starargs",
            extent
            );

    if (callExpr.kwargs().isValue() > 0)
        throw PythonToForaConversionError(
            "__inline_fora accepts no kwargs",
            extent
            );
    
    if (callExpr.args().size() != 1)
        throw PythonToForaConversionError(
            "__inline_fora accepts only one argument",
            extent
            );

    const PythonAstExpr& arg = callExpr.args()[0];

    if (!arg.isStr())
        throw PythonToForaConversionError(
            "__inline_fora accepts only string arguments",
            extent
            );

    const std::string& inlineForaCode = arg.getStr().s();
    const SimpleParseNode simpleParseNode = parseStringToSimpleParse(inlineForaCode);

    ParserExpressions p(true, CodeDefinitionPoint(), "");

    Expression inlineForaExpr = p.parseToExpression(simpleParseNode);

    if (!inlineForaExpr.isCreateFunction())
        throw PythonToForaConversionError(
            std::string(
                "only CreateFunction expressions are allowed in inline fora Code. got "
                ) + inlineForaExpr.tagName(),
            extent
            );

    return Expression::Constant(
        bindFreeVariablesInInlineForaExpressionToConstantUsingBuiltins(
            inlineForaExpr.getCreateFunction(),
            inlineForaExpr.freeVariables(),
            extent
            )
        );
    }

CSTValue PythonAstConverter::bindFreeVariablesInInlineForaExpressionToConstantUsingBuiltins(
        const Expression_CreateFunctionType& createFunctionExpression,
        const ImmutableTreeSet<Symbol>& freeVariables,
        const SimpleParseRange& extent
        ) const
    {
    // oh, STL-ops ...
    auto unboundFree = freeVariables - mBuiltinMemberMapping.keySet();

    if (unboundFree.size() > 0)
        throw PythonToForaConversionError(
            std::string("inline fora function had free variables,  ") + 
            prettyPrintString(unboundFree) + 
            " and this is forbidden",
            extent
            );

    return Fora::Language::bindFunctionWithValues(
        ClassMediator::Function(
            createFunctionExpression.name(),
            createFunctionExpression.predicate(),
            LexicalBindingMap(),
            CSTValue()
            ),
        mBuiltinMemberMapping,
        createFunctionExpression.objectMetadata()
        );
    }

Expression PythonAstConverter::convertExpressionToForaBoolean(const Expression& expr) const
    {
    //we need to convert this to a bool, which we do by calling PyBool (or equivalent as given)
    //and then calling 'Bool' on that
    return Expression::Apply(expr, 
            emptyTreeVec() 
                + Expression::Constant(
                    CSTValue(Symbol("Convert"))
                    ).normalApplyArg()
                + Expression::Constant(
                    CSTValue(JOV::OfType(Type::Integer(1,false)))
                    ).normalApplyArg()
            );
    }

Expression PythonAstConverter::convertPythonAstExpressionToForaBoolean(const PythonAstExpr& expr) const
    {
    Expression tr = convertPythonAstExpressionToFora(expr);

    return convertExpressionToForaBoolean(tr);
    }


Expression PythonAstConverter::convertPythonAstExpressionToFora(const PythonAstExpr& expr) const
    {
    Expression tr = convertPythonAstExpressionToFora_inner(expr);

    return CPPML::replaceCommonData(
        tr,
        ExpressionLocationMetadata::WithSimpleParseRange(expr.extent())
        );
    }

Expression PythonAstConverter::convertPythonAstStatementsToExpression(
        const ImmutableTreeVector<PythonAstStatement>& statements
        ) const
    {
    Expression result;

    for (auto s: statements)
        result = Expression::Sequence(result, convertPythonAstStatementToExpression(s));

    return result;
    }

Function PythonAstConverter::convertPythonAstExceptionHandlers(
        const ImmutableTreeVector<PythonAstExceptionHandler>& handlers
        ) const
    {
    if (handlers.size() == 0)
        return Function::Empty();

    Function tail = convertPythonAstExceptionHandlers(handlers.slice(1));

    PatternWithName pattern = PatternWithName::Anything(null());

    if (handlers[0].name())
        pattern = convertPythonAstExpressionToPattern(*handlers[0].name());

    if (handlers[0].type().isValue())
        {
        Expression e = convertPythonAstExpressionToFora(*handlers[0].type());

        pattern.pattern() = 
            Pattern::MatchBoth(
                pattern.pattern(), 
                Pattern::ExpressionMatch(
                    e,
                    TuplePattern(emptyTreeVec() + TuplePatternElement::VarArgs(null()))
                    )
                );
        }

    //augment the pattern to insist that it also matches 'PyforaException'
    pattern.pattern() = 
        Pattern::MatchBoth(
            pattern.pattern(), 
            Pattern::ExpressionMatch(
                Expression::Constant(CSTValue(Symbol("PyforaException"))),
                TuplePattern(emptyTreeVec() + TuplePatternElement::VarArgs(null()))
                )
            );

    TuplePattern pat = TuplePattern(
        emptyTreeVec() + TuplePatternElement::Normal(
            null(),
            pattern,
            null()
            )
        );

    return Function::Term(
        pat, 
        convertPythonAstStatementsToExpression(handlers[0].body()),
        tail
        );
    }

Expression PythonAstConverter::convertPythonAstStatementToExpression_inner(
        const PythonAstStatement& statement
        ) const
    {
    @match PythonAstStatement(statement)
        -| FunctionDef(name) ->> {
            assertValidNameIdentifier(name, statement.extent());

            return Expression::Assign(
                PatternWithName::Anything(null() << Symbol(name)),
                convertPythonAstFunctionDefToFora(
                    statement.getFunctionDef(),
                    statement.extent()
                    )
                );
            }
        -| ClassDef(name, bases, body, decoratorList) ->> {
            assertValidNameIdentifier(name, statement.extent());

            return Expression::Assign(
                PatternWithName::Anything(null() << Symbol(name)),
                convertPythonAstClassDefToFora(
                    statement.getClassDef(),
                    statement.extent(),
                    std::vector<std::string>()
                    )
                );
            }
        -| Return(Null()) ->> {
            return Expression::Return(Expression::Constant(mConstantConverter->noneValue()));
            }
        -| Return(Value(e)) ->> {
            return Expression::Return(convertPythonAstExpressionToFora(e));
            }
        -| Pass() ->> { return Expression::Constant(mConstantConverter->noneValue()); }
        -| Break() ->> { return Expression::Break(); }
        -| Continue() ->> { return Expression::Throw(Expression::Constant(CSTValue(Symbol("PyContinue"))), null()); }
        -| Raise(type, inst, tback) ->> {
            if (type && !inst && !tback)
                {   
                return Expression::Throw(
                    convertPythonAstExpressionToFora(*type),
                    Nullable<Expression>()
                    ); 
                }
            else
                throw PythonToForaConversionError(
                    "We only support 'raise' with a single argument",
                    statement.extent()
                    );
            }
        -| Expr(e) ->> {
            return convertPythonAstExpressionToFora(e);
            }
        -| For(target, iter, body, orelse) ->> {

            Expression leafExpr = 
                wrapExpressionInPyContinueCheck(
                    convertPythonAstStatementsToExpression(body)
                    );
                
            Symbol var = freshVarname(Symbol("@"), mentionedVariables(leafExpr));

            return Expression::Sequence(
                Expression::Foreach(
                    ListComprehensionChain::Term(
                        PatternWithName::Anything(null() << var),
                        null(),
                        convertPythonAstExpressionToFora(iter),
                        ListComprehensionChain::Leaf(
                            Expression::Sequence(
                                Expression::Assign(
                                    convertPythonAstExpressionToPattern(target),
                                    Expression::Variable(var)
                                    ),
                                leafExpr
                                )
                            )
                        )
                    ),
                convertPythonAstStatementsToExpression(orelse)
                );
            }
        -| While(cond, ifTrue, ifFalse) ->> {
            return Expression::Sequence(
                Expression::While(
                    convertPythonAstExpressionToForaBoolean(cond),
                    wrapExpressionInPyContinueCheck(convertPythonAstStatementsToExpression(ifTrue))
                    ),
                convertPythonAstStatementsToExpression(ifFalse)
                );
            }
        -| If(cond, ifTrue, ifFalse) ->> {
            return Expression::Branch(
                convertPythonAstExpressionToForaBoolean(cond),
                convertPythonAstStatementsToExpression(ifTrue),
                null() << convertPythonAstStatementsToExpression(ifFalse)
                );
            }
        -| TryExcept(body, handlers, orelse) ->> {
            if (orelse.size() > 0)
                throw PythonToForaConversionError(
                    "don't know how to convert else clauses in try statements",
                    statement.extent()
                    );

            return Expression::Try(
                convertPythonAstStatementsToExpression(body),
                convertPythonAstExceptionHandlers(
                    handlers
                    ),
                null(),
                false
                );
            }
        -| Assign(exprs, expression) ->> {
            if (exprs.size() == 0)
                throw PythonToForaConversionError(
                    "valid python expressions should have a left hand side",
                    statement.extent()
                    );
            if (exprs.size() == 1)
                return Expression::Assign(
                    convertPythonAstExpressionToPattern(exprs[0]),
                    convertPythonAstExpressionToFora(expression)
                    );
            else
                return Expression::Assign(
                    PatternWithName(
                        Pattern::Tuple(
                            TuplePattern(
                                mapITV(exprs, [this](PythonAstExpr ex) {
                                    return TuplePatternElement::Normal(
                                        null(),
                                        convertPythonAstExpressionToPattern(ex),
                                        null()
                                        );
                                    })
                                )
                            ),
                        null(),
                        null(),
                        ExpressionLocationMetadata()
                        ),
                    convertPythonAstExpressionToFora(expression)
                    );
            }
        -| Assert(test, msg) ->> {
            return Expression::Branch(
                convertPythonAstExpressionToForaBoolean(test),
                Expression::Constant(
                    mConstantConverter->noneValue()
                    ),
                null() << Expression::Throw(
                    Expression::Call(
                        Expression::Constant(
                            mAssertionError
                            ),
                        emptyTreeVec() + 
                            (msg.isNull() ? 
                                Expression::Call(
                                    Expression::Constant(
                                        mPyString
                                        ),
                                    emptyTreeVec() +
                                        Expression::Constant(CSTValue(""))
                                        .normalApplyArg()
                                ).normalApplyArg() :
                            convertPythonAstExpressionToFora(*msg).normalApplyArg())
                        ),
                    null()
                    )
                );
            }
        -| _ ->> {
            std::ostringstream oss;
            oss << PYFORA_CONVERSION_ERROR_MESSAGE;
            throw PythonToForaConversionError(
                oss.str(),
                statement.extent()
                );
            }
    }

Expression PythonAstConverter::convertPythonAstStatementToExpression(
        const PythonAstStatement& statement
        ) const
    {
    Expression tr = convertPythonAstStatementToExpression_inner(statement);

    return CPPML::replaceCommonData(
        tr,
        ExpressionLocationMetadata::WithSimpleParseRange(
            statement.extent()
            )
        );
    }

PatternWithName PythonAstConverter::convertPythonAstExpressionToPattern_inner(
        const PythonAstExpr& expr
        ) const
    {
    @match PythonAstExpr(expr)
        -| Name(identifier, _) ->> {
            assertValidNameIdentifier(identifier, expr.extent());
            return PatternWithName::Anything(null() << Symbol(identifier));
            }
        -| Tuple(elts, Store()) ->> {
            return PatternWithName(
                Pattern::ExpressionMatch(
                    Expression::Constant(
                        CSTValue::Tuple(
                            emptyTreeVec() + 
                                CSTValue::Tag(Symbol("TupleAssign")) + 
                                CSTValue((int64_t)elts.size())
                            )
                        ),
                    TuplePattern(
                        mapITV(elts, [&](PythonAstExpr e) {
                            return TuplePatternElement::Normal(
                                convertPythonAstExpressionToPattern(e)
                                );
                            })
                        )
                    ),
                null(),
                null(), 
                ExpressionLocationMetadata::WithSimpleParseRange(expr.extent())
                );
            }
        -| _ ->> {
            std::ostringstream oss;
            oss << PYFORA_CONVERSION_ERROR_MESSAGE;
            throw PythonToForaConversionError(
                oss.str(),
                expr.extent()
                );
            }
    }

PatternWithName PythonAstConverter::convertPythonAstExpressionToPattern(
        const PythonAstExpr& expr
        ) const
    {
    PatternWithName tr = convertPythonAstExpressionToPattern_inner(expr);

    return PatternWithName(
        tr.pattern(),
        tr.name(),
        tr.condition(),
        ExpressionLocationMetadata::WithSimpleParseRange(
            expr.extent()
            )
        );
    }

Expression PythonAstConverter::convertPythonAstClassDefToFora(
        const PythonAstStatement_ClassDefType& classDef,
        const SimpleParseRange& extent,
        const ImmutableTreeVector<std::string>& baseClasses
        ) const
    {
    const std::string& className = classDef.name();
    ImmutableTreeVector<PythonAstExpr> bases = classDef.bases();
    ImmutableTreeVector<PythonAstStatement> body = classDef.body();
    ImmutableTreeVector<PythonAstExpr> decoratorList = classDef.decorator_list();

    if (decoratorList.size() > 0) {
        throw PythonToForaConversionError(
            "don't know how to convert decorator lists for classes right now",
            extent
            );
        }

    if (bases.size() > 0 && baseClasses.size() != bases.size()) {
        throw PythonToForaConversionError(
            "don't know how to deal with base classes in nested class definitions right now",
            extent
            );
        }

    ImmutableTreeVector<ClassDefinitionTerm> classDefinitionTerms;

    for (const auto& statement: body) {
        classDefinitionTerms = classDefinitionTerms +
            convertPythonClassBodyStatementToForaClassDefinitionTerms(
                statement,
                className
                );
        }

    classDefinitionTerms = classDefinitionTerms +
        ClassDefinitionTerm::ObjectTerm(
            ObjectDefinitionTerm::Member(
                Symbol("__class__"),
                Expression::Variable(Symbol(className)),
                1
                )
            );


    ImmutableTreeVector<ApplyArgument> basesMember;
    for (const std::string& baseClass: baseClasses)
        basesMember = basesMember + ApplyArgument::Normal(null(),
                                                          Expression::Variable(Symbol(baseClass)));
    classDefinitionTerms = classDefinitionTerms +
        ClassDefinitionTerm::Static(
            ObjectDefinitionTerm::Member(
                Symbol("__bases__"),
                mPythonTupleConverter->createTupleExpression(
                    Expression::CreateTuple(
                        basesMember
                        )
                    ),
                1
                )
            );

    auto mixins =
        (baseClasses.size() == 0 && mPyObjectBaseMixin.type().isClass()) ?
        baseClasses + std::string("object") :
        baseClasses;

    for (const std::string& baseClass: mixins)
        {
        if (baseClass == "object")
            {
            classDefinitionTerms = classDefinitionTerms +
                ClassDefinitionTerm::ObjectTerm(
                    ObjectDefinitionTerm::Mixin(
                        Expression::Constant(
                            CSTValue(mPyObjectBaseMixin)
                            )
                        )
                    );

            //the class object itself is also a PyObject
            classDefinitionTerms = classDefinitionTerms +
                ClassDefinitionTerm::Static(
                    ObjectDefinitionTerm::Mixin(
                        Expression::Constant(
                            CSTValue(mPyObjectBaseMixin)
                            )
                        )
                    );
            }
        else
            {
            classDefinitionTerms = classDefinitionTerms +
                ClassDefinitionTerm::Static(
                    ObjectDefinitionTerm::Mixin(
                        Expression::Variable(Symbol(baseClass))
                        )
                    );
            }
        }

    ClassDefinitionBody classDefinitionBody = ClassDefinitionBody::Empty();

    for (long k = (long)classDefinitionTerms.size() - 1; k >= 0; k--)
        classDefinitionBody = ClassDefinitionBody::Term(
            ClassDefinitionTermWithMetadata(
                classDefinitionTerms[k],
                CSTValue()
                ),
            classDefinitionBody
            );

    return Expression::CreateClass(
        className,
        ClassDefinition(
            classDefinitionBody,
            null() << Symbol(className),
            null() << Symbol("@self"),
            ExpressionLocationMetadata::WithSimpleParseRange(extent)
            ),
        CSTValue()
        );
    }

Expression PythonAstConverter::replaceUnconvertiblesWithThrowExprs(
        const Expression& e,
        const ImmutableTreeVector<Symbol>& unconvertibleSymbols
        ) const
    {
    ImmutableTreeMap<Symbol, Expression> remap;
    for (const auto& sym: unconvertibleSymbols)
        {
        remap = remap + std::make_pair(
            sym,
            checkVariableValidityExpression(sym)
            );
        }

    return rebindFreeAs(e, remap);
    }

Function PythonAstConverter::convertFunctionDefToForaFunction(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    std::pair<Expression, TuplePattern> functionBodyAndPattern = 
        convertFunctionDefToForaFunctionBodyAndPattern(
            functionDef,
            extent
            );

    Expression functionBody = initializeUnboundVariablesForFunction(
        functionBodyAndPattern.second,
        functionBodyAndPattern.first
        );

    if (hasYield(functionDef))
        functionBody = 
            Expression::Call(
                Expression::Constant(mPyGeneratorFactory),
                emptyTreeVec() + 
                    Expression::CreateFunction(
                        "<generator>",
                        Function::Term(TuplePattern(), functionBody, Function::Empty()),
                        CSTValue()
                        ).normalApplyArg()
                );

    return Function::Term(
        functionBodyAndPattern.second,
        functionBody,
        invalidCallHandler(
            functionDef.name(),
            functionBodyAndPattern.second
            )
        );
    }

Expression PythonAstConverter::checkVariableValidityExpression(Symbol s) const
    {  
    return Expression::Try(
        Expression::Sequence(
            Expression::Apply(
                Expression::Constant(CSTValue(Symbol("CheckValueIsPyforaInvalidVariableSymbol"))),
                emptyTreeVec() + 
                    ApplyArgument::Normal(Expression::Variable(Symbol(s)))
                ),
            Expression::Variable(Symbol(s))
            ),
        Function::Term(
            TuplePattern(
                emptyTreeVec() + 
                    TuplePatternElement::VarArgs(null())
                ),
            Expression::Constant(CSTValue(mPyObjectBaseMixin))
            .member(Symbol("__pyfora_invalid_variable_access__"))(
                Expression::Variable(Symbol(s)), 
                Expression::Constant(CSTValue(Symbol(s)))
                ),
            Function::Empty()
            ),
        null(),
        false
        );
    }
    
std::pair<Expression, TuplePattern> 
PythonAstConverter::convertFunctionDefToForaFunctionBodyAndPattern(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    const std::string& functionName = functionDef.name();
    PythonAstArguments args = functionDef.args();
    ImmutableTreeVector<PythonAstStatement> body = functionDef.body();
    
    ImmutableTreeVector<PythonAstExpr> decoratorList = functionDef.decorator_list();

    if (decoratorList.size() > 0) {
        throw PythonToForaConversionError(
            "don't know how to convert decorator lists for functions right now",
            extent
            );
        }

    checkFunctionArgs(args, extent);

    ImmutableTreeVector<TuplePatternElement> foraArgs = computeForaArgs(args);
    TuplePattern pattern = TuplePattern(foraArgs);
    Expression functionBody = convertPythonAstStatementsToExpression(body);

    functionBody = Expression::Sequence(
        functionBody,
        Expression::Return(
            Expression::Constant(
                mConstantConverter->noneValue()
                )
            )
        );

    return std::make_pair(functionBody, pattern);
    }

Expression PythonAstConverter::addWithBlockReturnStatement(
                Expression expr, 
                ImmutableTreeVector<std::string> assigned
                ) const
    {
    return Expression::Sequence(
        expr,
        Expression::Return(
            mPythonTupleConverter->createTupleExpression(
                Expression::CreateTuple(
                    emptyTreeVec() +
                    ApplyArgument::Normal(
                        null(),
                        getDictOfAssignedVariables(assigned)
                        ) +
                    ApplyArgument::Normal(
                        null(),
                        constantExpressionForImplVal(
                            constantConverter()->convertInt(0)
                            )
                        ) +
                    ApplyArgument::Normal(
                        null(),
                        constantExpressionForImplVal(
                            constantConverter()->convertInt(0)
                            )
                        )
                    )
                )
            )
        );
    }

Expression PythonAstConverter::convertPythonAstWithBlockFunctionDefToFora(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent,
        ImmutableTreeVector<std::string> varsToConsiderFree
        ) const
    {
    ImmutableTreeSet<Symbol> varsToConsiderFreeSet;

    for (auto v: varsToConsiderFree)
        varsToConsiderFreeSet = varsToConsiderFreeSet + Symbol(v);

    const std::string& functionName = functionDef.name();

    std::pair<Expression, TuplePattern> functionBodyAndPattern = 
        convertFunctionDefToForaFunctionBodyAndPattern(
            functionDef,
            extent
            );

    ImmutableTreeVector<std::string> assigned;
    for (auto var: functionBodyAndPattern.first.assignedVariables())
        if (var.toString()[0] != '@')
            assigned = assigned + var.toString();

    @match Expression(functionBodyAndPattern.first)
        -| Sequence(inner, Return(Constant(shouldBeNone))) ->> {
            lassert(shouldBeNone == CSTValue(mConstantConverter->noneValue()));

            functionBodyAndPattern.first = inner;
            }

    Expression functionBody = functionBodyAndPattern.first;

    ImmutableTreeSet<Symbol> freeVarsToCheck = functionBody.freeVariables();

    for (auto s: freeVarsToCheck)
        if (!varsToConsiderFreeSet.contains(s))
            functionBody = rebindFreeAs(functionBody, emptyTreeMap() + s + checkVariableValidityExpression(s));

    functionBody = wrapWithBlockFunctionBodyInTryCatch(
        functionBody,
        assigned
        );

    functionBody = 
        addWithBlockReturnStatement(functionBody, assigned);
    
    for (auto s: freeVarsToCheck)
        if (!varsToConsiderFreeSet.contains(s))
            functionBody = Expression::Let(
                s, 
                Expression::Constant(CSTValue(Symbol("PyforaUninitializedVariable"))),
                functionBody
                );
            else
        if (functionBody.assignedVariables().contains(s))
            {
            //put a wrapper around 's' so that it can be assigned to in the interior scope
            Symbol sWrapper = freshVarname("wrapper_", mentionedVariables(functionBody) + s);

            functionBody = Expression::Let(
                sWrapper,
                Expression::Variable(s),
                Expression::Let(
                    s,
                    Expression::Variable(sWrapper),
                    functionBody
                    )
                );
            }

    Function function = Function::Term(
        functionBodyAndPattern.second,
        functionBody,
        Function::Empty()
        );

    return createObjectImplementingCallOperatorForFunction(
        function,
        functionName,
        null() << extent
        );
    }

Expression PythonAstConverter::getDictOfAssignedVariables(
        const ImmutableTreeVector<std::string>& assignedVariables
        ) const
    {
    ImmutableTreeVector<Expression> keys;
    ImmutableTreeVector<Expression> values;

    for (const auto& name: assignedVariables)
        {
        keys = keys + Expression::Constant(
            CSTValue(
                mConstantConverter->convertString(name)
                )
            );
        values = values + Expression::Variable(
            Symbol(name)
            );
        }

    return mPythonDictConverter->createDictExpr(
        keys,
        values
        );
    }

Expression PythonAstConverter::wrapWithBlockFunctionBodyInTryCatch(
        const Expression& functionBody,
        const ImmutableTreeVector<std::string>& assignedVariables
        ) const
    {
    Symbol catchVar = freshVarname(
        "exception_var",
        mentionedVariables(
            functionBody
            )
        );

    // TODO not dealing with intermediate assigned variables yet

    Symbol stacktraceVar = Symbol("@stacktrace");

    Function catchFun = 
        Function::Term(
            TuplePattern(
                emptyTreeVec() +
                    TuplePatternElement::Normal(
                        null(),
                        PatternWithName(
                            Pattern::Anything(),
                            null() << catchVar,
                            null(),
                            ExpressionLocationMetadata::Empty()
                            ),
                        null()
                        )
                ),
            Expression::Return(
                mPythonTupleConverter->createTupleExpression(
                    Expression::CreateTuple(
                        emptyTreeVec() +
                        ApplyArgument::Normal(
                            null(),
                            getDictOfAssignedVariables(assignedVariables)
                            ) +
                        ApplyArgument::Normal(
                            null(),
                            Expression::Variable(
                                stacktraceVar
                                )
                            ) +
                        ApplyArgument::Normal(
                            null(),
                            Expression::Variable(catchVar)
                            )
                        )
                    )
                ),
            Function::Empty()
            );

    return Expression::Try(
        functionBody,
        catchFun,
        null() << stacktraceVar,
        false
        );        
    }

Expression PythonAstConverter::convertPythonAstFunctionDefToFora(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    const std::string& functionName = functionDef.name();

    Function function = convertFunctionDefToForaFunction(
        functionDef,
        extent
        );

    return createObjectImplementingCallOperatorForFunction(
        function,
        functionName,
        null() << extent
        );
    }

Expression PythonAstConverter::createObjectImplementingCallOperatorForFunction(
        const Function& function,
        const std::string& functionName,
        Nullable<SimpleParseRange> extent
        ) const
    {
    return Expression::CreateObject(
        functionName,
        ObjectDefinition(
            ObjectDefinitionBody::Term(
                ObjectDefinitionTermWithMetadata(
                    ObjectDefinitionTerm::Call(
                        function
                        ),
                    CSTValue()
                    ),
                mPyObjectBaseMixin.type().isClass() ? 
                    ObjectDefinitionBody::Term(
                        ObjectDefinitionTermWithMetadata(
                            ObjectDefinitionTerm::Mixin(
                                Expression::Constant(
                                    CSTValue(mPyObjectBaseMixin)
                                    )
                                ),
                            CSTValue()
                            ),
                        ObjectDefinitionBody::Empty()
                        ) 
                :   ObjectDefinitionBody::Empty()
                ),
            null() << Symbol(functionName),
            extent ? 
                ExpressionLocationMetadata::WithSimpleParseRange(*extent)
            :   ExpressionLocationMetadata::Empty()
            ),
        CSTValue()
        );
    }


/*
Called from convertPythonClassBodyFunctionDefToForaClassDefinitionTerm which verifies
expected properties on `args`
*/
ImmutableTreeVector<ClassDefinitionTerm>
PythonAstConverter::convertPythonClassBodyStaticMethodFunctionDefToForaClassDefinitionTerms(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    PythonAstStatement_FunctionDefType functionDefWithoutDecorators = functionDef;
    functionDefWithoutDecorators.decorator_list() = emptyTreeVec();

    Function function = 
        convertFunctionDefToForaFunction(
            functionDefWithoutDecorators,
            extent
            );

    return emptyTreeVec() + 
        ClassDefinitionTerm::Static(
            noncapturingObjectMember(
                functionDef.name(),
                createObjectImplementingCallOperatorForFunction(
                    function,
                    functionDef.name(),
                    null() << extent
                    )
                )
            ) + 
        ClassDefinitionTerm::ObjectTerm(
            noncapturingObjectMember(
                functionDef.name(),
                createObjectImplementingCallOperatorForFunction(
                    function,
                    functionDef.name(),
                    null() << extent
                    )
                )
            );
    }

/*
Called from convertPythonClassBodyFunctionDefToForaClassDefinitionTerm which verifies
expected properties on `args`
*/
ClassDefinitionTerm 
PythonAstConverter::convertPythonClassBodyPropertyToForaClassDefinitionTerm(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    PythonAstStatement_FunctionDefType functionDefWithoutDecorators = functionDef;
    functionDefWithoutDecorators.decorator_list() = emptyTreeVec();

    Function function = 
        convertFunctionDefToForaFunction(
            functionDefWithoutDecorators,
            extent
            );

    return ClassDefinitionTerm::ObjectTerm(
        ObjectDefinitionTerm::Anything(
            Function::Term(
                TuplePattern(
                    emptyTreeVec() + 
                        TuplePatternElement::Normal(
                            PatternWithName::Constant(CSTValue(Symbol("Member")))
                            ) +
                    TuplePatternElement::Normal(
                        PatternWithName::Constant(CSTValue(Symbol(functionDef.name())))
                        )
                    ),
                Expression::Call(
                    Expression::Call(
                        Expression::Constant(mPyBoundMethod),
                        emptyTreeVec() +
                        Expression::Variable(Symbol("@self")).normalApplyArg() +
                        Expression::CreateFunction(
                            "__property_fun",
                            function,
                            CSTValue()
                            ).normalApplyArg() +
                        Expression::Constant(
                            CSTValue(Symbol(functionDef.name()))
                            ).normalApplyArg()
                        ),
                    emptyTreeVec()
                    ),                
                Function::Empty()
                )
            )
        );
    }


ImmutableTreeVector<TuplePatternElement> PythonAstConverter::computeForaArgs(
        const PythonAstArguments& pythonArgs
        ) const
    {
    ImmutableTreeVector<TuplePatternElement> foraArgs;

    int defaultArgCount = pythonArgs.defaults().size();
    int totalArgumentCount = pythonArgs.args().size();
    int nonDefaultArgCount = totalArgumentCount - defaultArgCount;
    for (long k = 0; k < nonDefaultArgCount; k++)
        foraArgs = foraArgs + TuplePatternElement::Normal(
            null(),
            convertPythonAstExpressionToPattern(pythonArgs.args()[k]),
            null()
            );
    int idx = 0;
    for (long k = nonDefaultArgCount; k < totalArgumentCount; k++)
        foraArgs = foraArgs + TuplePatternElement::Normal(
            null(),
            convertPythonAstExpressionToPattern(pythonArgs.args()[k]),
            null() << convertPythonAstExpressionToFora(pythonArgs.defaults()[idx++])
            );

    return foraArgs;
    }

}


