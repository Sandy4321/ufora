/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#include "PythonAstConverter.hppml"
#include "PythonListConverter.hppml"
#include "PythonTupleConverter.hppml"
#include "PythonDictConverter.hppml"
#include "PythonToForaConversionError.hppml"
#include "PythonConstantConverter.hppml"
#include "../../Judgment/JudgmentOnValue.hppml"
#include "../../Core/ImplValContainerUtilities.hppml"
#include "../../Language/FunctionStage1Simulation.hppml"
#include "../../Language/ExpressionLocationMetadata.hppml"
#include "../../../core/cppml/CPPMLVisit.hppml"
#include "../../../core/cppml/CPPMLTransform.hppml"
#include "../../../core/Logging.hpp"
#include "../../Language/RebindFree.hppml"

#define PYFORA_CONVERSION_ERROR_MESSAGE "Pyfora can't convert this code. See http://docs.pyfora.com/en/latest/tutorials/intro.html#pure-python"


namespace {

using namespace Fora;

//take a member name (e.g. 'x') and return the private form of the name (the
//name used by generated code) that refers to it. We use a space because it cannot
//conflict with the names produced by actual python code.
std::string publicDataMemberNameToPrivate(std::string name)
    {
    return "@" + name;
    }

ObjectDefinitionTerm noncapturingObjectMember(std::string name, Expression expr)    
    {
    return 
        ObjectDefinitionTerm::Anything(
            Function::Term(
                TuplePattern(
                    emptyTreeVec() + 
                        TuplePatternElement::Normal(PatternWithName::Constant(CSTValue(Symbol("Member")))) + 
                        TuplePatternElement::Normal(PatternWithName::Constant(CSTValue(Symbol(name))))
                    ),
                expr,
                Function::Empty()
                )
            );    
    }

ClassDefinitionTerm
createInvalidNumberOfArgumentsClassDefinitionTerm(const std::string& name) {
    return ClassDefinitionTerm::ObjectTerm(
        ObjectDefinitionTerm::Member(
            Symbol(name),
            Expression::Throw(
                Expression::Constant(
                    CSTValue(name + "() takes no arguments; more than one given")
                    ),
                null()                    
                ),
            1
            )
        );        
    }

class AssertOnlySimpleInitStatementsVisitor {
private:
    const std::string& mSelfName;
public:
    AssertOnlySimpleInitStatementsVisitor(const std::string& inSelfName) :
        mSelfName(inSelfName)
        {
        }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        if (expr.isYield())
            throw PythonToForaConversionError(
                "Yield is not supported in __init__ methods",
                expr.extent()
                );
        }

    void processDown(const PythonAstStatement& stmt, bool& outContinue)
        {
        if (stmt.isFunctionDef() or stmt.isClassDef())
            throw PythonToForaConversionError(
                "don't know how to handle function or class definitions in __init__ methods",
                stmt.extent()
                );

        if (stmt.isFunctionDef() or stmt.isReturn())
            throw PythonToForaConversionError(
                "Return statements are currently not supported in __init__ methods",
                stmt.extent()
                );
        
        if (stmt.isAssign()) {
            if (stmt.getAssign().targets().size() != 1)
                throw PythonToForaConversionError(
                    "don't know how to handle multiple assignment in __init__ methods",
                    stmt.extent()
                    );

            PythonAstExpr target = stmt.getAssign().targets()[0];

            if (target.isName()) {
                if (target.getName().id() == mSelfName) {
                    std::ostringstream oss;
                    oss << "don't know how to handle reassignments to self variable `" 
                        << mSelfName << "' in __init__ methods";
                    throw PythonToForaConversionError(
                        oss.str(), stmt.extent()
                        );
                    }
                }
            }
        }
};

class HasYieldFunctionBodyVisitor {
private:
    bool& mHasYield;
public:
    HasYieldFunctionBodyVisitor(
                bool& inHasYield
                ): 
            mHasYield(inHasYield)
        {
        }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        @match PythonAstExpr(expr)
            -| Yield(id, _) ->> {
                mHasYield = true;
                }
            -| Lambda() ->> { outContinue = false; }
            -| GeneratorExp() ->> { outContinue = false; }
            -| _ ->> {}
            ;
        }

    void processDown(const PythonAstStatement& expr, bool& outContinue)
        {
        @match PythonAstStatement(expr)
            -| FunctionDef() ->> {
                outContinue = false;
                }
            -| ClassDef() ->> {
                outContinue = false;
                }
            -| _ ->> {}
            ;
        }

};
        
template<class T>
bool hasYield(const T& value)
    {
    bool result = false;

    HasYieldFunctionBodyVisitor visitor(result);

    visit(value, visitor);

    return result;
    }


class ExtractVariablesReferencedInFunctionBodyVisitor {
private:
    std::set<std::string>& mReferencedVariables;
public:
    ExtractVariablesReferencedInFunctionBodyVisitor(
            std::set<std::string>& inReferencedVariables
            ): mReferencedVariables(inReferencedVariables)
        {
        }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        @match PythonAstExpr(expr)
            -| Name(id, _) ->> {
                mReferencedVariables.insert(id);
                }
            -| _ ->> {}
            ;
        }
};

class RewriteSelfSetAttrsTransformer {
private:
    std::set<std::pair<std::string, std::string>>& mSelfSetItemMap;
    const std::set<std::string>& mReferencedVariables;
    const std::string& mSelfName;
public:
    RewriteSelfSetAttrsTransformer(
            std::set<std::pair<std::string, std::string>>& inSelfSetItemMap,
            const std::set<std::string>& inReferencedVariables,
            const std::string& selfName
            ):
        mSelfSetItemMap(inSelfSetItemMap),
        mReferencedVariables(inReferencedVariables),
        mSelfName(selfName)
        {
        }    

    template<class T>
    Nullable<T> processDown(const T& t, bool& b) const
        {
        return null();
        }

    template<class T>
    Nullable<T> processUp(const T& t) const
        {
        return null();
        }

    Nullable<PythonAstExpr> processDown(
            const PythonAstExpr& expr, bool& ioContinue
            ) const
        {
        @match PythonAstExpr(expr) 
            -| Attribute(value, attr, ctx) ->> {
                if (!value.isName() or 
                    value.getName().id() != mSelfName)
                    return null();

                std::string replacingName = getReplacingName(
                    attr
                    );

                mSelfSetItemMap.insert(
                    std::make_pair(
                        attr,
                        replacingName
                        )
                    );

                return null() << 
                    PythonAstExpr::Name(
                        replacingName,
                        ctx                        
                        );
                }
            -| _ ->> { return null(); }
        }
    
private:
    std::string getReplacingName(const std::string& attrName) const 
        {
        std::string tr = mSelfName + "_" + attrName;
        while (mReferencedVariables.find(tr) != mReferencedVariables.end())
            {
            tr = tr + "_";
            }
        return tr;
        }
};

Expression makeCreateInstanceCall(
        const std::set<std::pair<std::string, std::string>>& selfSetItemMap,
        const std::string& className
        )
    {
    ImmutableTreeVector<ApplyArgument> arguments;

    arguments = arguments + 
        ApplyArgument::Normal(
            null(),
            Expression::Constant(
                CSTValue(
                    Symbol("CreateInstance")
                    )
                )
            );

    for (const auto& p: selfSetItemMap) {
        arguments = arguments + 
            ApplyArgument::Normal(
                null() << Symbol(publicDataMemberNameToPrivate(p.first)),
                Expression::Variable(
                    Symbol(p.second)
                    )
                );
        }

    return Expression::Apply(
        Expression::Variable(
            Symbol(className)
            ),
        arguments
        );
    }

void assertOnlySimpleInitStatements(
        const ImmutableTreeVector<PythonAstStatement>& functionBody,
        const std::string& inSelfName
        )
    {
    AssertOnlySimpleInitStatementsVisitor visitor(inSelfName);
    visit(functionBody, visitor);
    }

std::set<std::string> extractVariablesReferencedInFunctionBody(
        const ImmutableTreeVector<PythonAstStatement>& functionBody
        )
    {
    std::set<std::string> referencedVariables;
    ExtractVariablesReferencedInFunctionBodyVisitor visitor(referencedVariables);
    visit(functionBody, visitor);
    return referencedVariables;
    }

std::pair<
    ImmutableTreeVector<PythonAstStatement>, 
    std::set<std::pair<std::string, std::string>>
    > rewriteSelfSetAttrs(
        const TuplePatternElement& selfArg,
        const ImmutableTreeVector<PythonAstStatement>& body        
        )
    {
    std::string selfName;
        {
        lassert(selfArg.isNormal());

        auto nullableName = selfArg.getNormal().match().name();

        lassert(nullableName.isValue());
        selfName = nullableName->toString();
        }

    assertOnlySimpleInitStatements(body, selfName);

    std::set<std::string> referencedVariables = 
        extractVariablesReferencedInFunctionBody(
            body
            );

    std::set<std::pair<std::string, std::string>> selfSetItemMap;

    RewriteSelfSetAttrsTransformer transformer(
        selfSetItemMap,
        referencedVariables,
        selfName
        );

    ImmutableTreeVector<PythonAstStatement> transformedBody = 
        transform(body, transformer);

    return std::make_pair(transformedBody, selfSetItemMap);
    }

void checkFunctionArgs(
        const PythonAstArguments& args,
        const SimpleParseRange& extent
        )
    {
    if (args.vararg().isValue())
        throw PythonToForaConversionError(
            "don't know how to handle *args yet",
            extent
            );
    if (args.kwarg().isValue())
        throw PythonToForaConversionError(
            "don't know how to handle **kwargs yet",
            extent
            );
    }

// we could probably move a more general 'slice' member function
// on PythonAstArguments, but this serves our purposes for now
PythonAstArguments dropFirstNormalArg(const PythonAstArguments& args)
    {
    if (args.defaults().size() < args.args().size())
        {
        return PythonAstArguments(
            args.args().slice(1),
            args.vararg(),
            args.kwarg(),
            args.defaults()
            );
        }

    lassert(args.defaults().size() == args.args().size());
        
    return PythonAstArguments(
        args.args().slice(1),
        args.vararg(),
        args.kwarg(),
        args.defaults().slice(1)
        );
    }

} // anonymous namespace

namespace Fora {

ImplValContainer getModuleMember(ImplValContainer module, std::string memberName)
    {
    FunctionStage1::Simulation simulation(100);

    FunctionStage1::ExpressionEvaluationResult result = 
        simulation.evaluateApply(
            emptyTreeVec() + 
                module + 
                ImplValContainerUtilities::createSymbol(Symbol("Member")) + 
                ImplValContainerUtilities::createSymbol(Symbol(memberName))
            );

    lassert(result.isResult());
    
    return result.getResult().val();
    }



PythonAstConverter::PythonAstConverter(
            PolymorphicSharedPtr<PythonConstantConverter> constantConverter,
            PolymorphicSharedPtr<PythonListConverter> listConverter,
            PolymorphicSharedPtr<PythonTupleConverter> tupleConverter,
            PolymorphicSharedPtr<PythonDictConverter> dictConverter,
            ImplValContainer pyforaBuiltins
            )
        : mConstantConverter(constantConverter),
          mPythonListConverter(listConverter),
          mPythonTupleConverter(tupleConverter),
          mPythonDictConverter(dictConverter),
          mPyforaBuiltins(pyforaBuiltins)
    {
    mPyBoundMethod = getModuleMember(pyforaBuiltins, "PyBoundMethod");

    mPyObjectBaseMixin = getModuleMember(pyforaBuiltins, "PyObjectBase");
        
    mPyGeneratorFactory = getModuleMember(pyforaBuiltins, "Generator");

    mPySliceFactory = getModuleMember(pyforaBuiltins, "Slice");

    mPyListType = getModuleMember(pyforaBuiltins, "ListType");

    mTypeError = getModuleMember(pyforaBuiltins, "TypeError");

    mPyString = getModuleMember(pyforaBuiltins, "PyString");

    mPyDictType = getModuleMember(pyforaBuiltins, "DictType");
    }

PolymorphicSharedPtr<PythonConstantConverter> PythonAstConverter::constantConverter() const
    {
    return mConstantConverter;
    }

Function PythonAstConverter::invalidCallHandler(
        const std::string& functionName,
        const TuplePattern& patternForFunction
        ) const
    {
    uint32_t nNormalArgs = 0;
    uint32_t nDefaultArgs = 0;
    
    for (const auto& tuplePatternElement: patternForFunction.matchers())
        {
        @match TuplePatternElement(tuplePatternElement) 
            -|  Normal(_, _, defaultValueOrNull) ->> {
                nNormalArgs++;
                if (defaultValueOrNull.isValue()) 
                    nDefaultArgs++;
                }
            -|  VarArgs(_) ->> {
                // the matchers for the original function will handle this, 
                // and we'll never need to handle it here
                return Function::Empty()
                }
            ;
        }

    Symbol argsSymbol = Symbol("args");
    Expression argsVariable = Expression::Variable(argsSymbol);
    Expression rawErrorString;

    if (nDefaultArgs > 0)
        rawErrorString = invalidCallHandlerWithDefaultArgsRawErrorString(
            nNormalArgs,
            nDefaultArgs,
            functionName,
            argsVariable
            );
    else
        rawErrorString = invalidCallHandlerNoDefaultArgsRawErrorString(
            nNormalArgs,
            functionName,
            argsVariable
            );

    Expression pyStringifiedErrorString =
        Expression::Call(
            Expression::Constant(
                mPyString
                ),
            emptyTreeVec() + rawErrorString.normalApplyArg()
            );

    Expression functionBody = 
        Expression::Throw(
            Expression::Call(
                Expression::Constant(
                    mTypeError
                    ),
                emptyTreeVec() +
                    pyStringifiedErrorString.normalApplyArg()
                ),
            null()
            );

    return Function::Term(
        TuplePattern(
            emptyTreeVec() +
            TuplePatternElement::VarArgs(
                null() << argsSymbol
                )
            ),
        functionBody,
        Function::Empty()
        );
    }

Expression PythonAstConverter::invalidCallHandlerWithDefaultArgsRawErrorString(
        uint32_t nNormalArgs,
        uint32_t nDefaultArgs,
        const std::string& functionName,
        const Expression& argsVariable
        ) const
    {
    uint32_t nNonDefaultArgs = nNormalArgs - nDefaultArgs;

    std::ostringstream oss;
    oss << functionName << "() takes at most " << nNormalArgs 
        << (nNormalArgs == 1 ? " argument (" : " arguments (")
        ;

    Expression tooManyCallArgsPrefix = Expression::Constant(CSTValue(oss.str()));

    oss.str("");
    oss.clear();
    oss << functionName << "() takes at least " << nNonDefaultArgs 
        << (nNonDefaultArgs == 1 ? " argument (" : " arguments (")
        ;

    Expression tooFewCallArgsPrefix = Expression::Constant(CSTValue(oss.str()));

    Symbol nCallArgsGivenSymbol = Symbol("nCallArgsGiven");
    Expression nCallArgsGivenString = 
        Expression::Call(
            Expression::Constant(
                CSTValue(JOV::OfType(Type::String()))
                ),
            emptyTreeVec() +
                Expression::Variable(nCallArgsGivenSymbol).normalApplyArg()
        );

    Expression suffix = 
        Expression::BinaryOperator(
            nCallArgsGivenString,
            Symbol("+"),
            Expression::Constant(CSTValue(" given)"))
            );

    return Expression::Let(
        nCallArgsGivenSymbol,
        Expression::Call(
            Expression::Constant(
                CSTValue(Symbol("size"))
                ),
            emptyTreeVec() +
                argsVariable.normalApplyArg()
            ),
        Expression::Branch(
            Expression::BinaryOperator(
                Expression::Variable(nCallArgsGivenSymbol),
                Symbol("<"),
                Expression::Constant(CSTValue(nNonDefaultArgs))
                ),
            Expression::BinaryOperator(
                tooFewCallArgsPrefix,
                Symbol("+"),
                suffix
                ),
            null() << Expression::BinaryOperator(
                tooManyCallArgsPrefix,
                Symbol("+"),
                suffix
                )
            )
        );
    }

Expression PythonAstConverter::invalidCallHandlerNoDefaultArgsRawErrorString(
        uint32_t nNormalArgs,
        const std::string& functionName,
        const Expression& argsVariable
        ) const
    {
    std::ostringstream oss;
    oss << functionName << "() takes ";

    if (nNormalArgs == 0) {
        oss << "no arguments";
        }
    else {
        oss << "exactly " << nNormalArgs << " argument"
            << (nNormalArgs == 1 ? "" : "s")
        ;
        }
    oss << " (";

    Expression prefixString = Expression::Constant(CSTValue(oss.str()));

    Expression nCallArgsGivenString =
        Expression::Call(
            Expression::Constant(
                CSTValue(JOV::OfType(Type::String()))
                ),
            emptyTreeVec() +
                Expression::Call(
                    Expression::Constant(
                        CSTValue(Symbol("size"))
                        ),
                    emptyTreeVec() +
                        argsVariable.normalApplyArg()
                    ).normalApplyArg()
        );

    Expression suffixString = Expression::Constant(CSTValue(" given)"));

    return
        Expression::BinaryOperator(
            prefixString,
            Symbol("+"),
            Expression::BinaryOperator(
                nCallArgsGivenString,
                Symbol("+"),
                suffixString
                )
            );
    }


/*
We've got an ITV<ClassDefinitionTerm> here because certain python class body statements produce
more than one Fora ClassDefinitionTerm, for example __init__ gives a Constructor and (possibly)
DataMembers.
*/
ImmutableTreeVector<ClassDefinitionTerm>
PythonAstConverter::convertPythonClassBodyStatementToForaClassDefinitionTerms(
        const PythonAstStatement& statement,
        const std::string& className
        ) const
    {
    @match PythonAstStatement(statement)
        -| FunctionDef(_, _, _, _) ->> {
            return convertPythonClassBodyFunctionDefToForaClassDefinitionTerms(
                statement.getFunctionDef(),
                statement.extent(),
                className
                );
            }
        -| Pass() ->> {
            return emptyTreeVec();
            }
        -| Expr(Str(s)) ->> {
            ///This swallows doc strings
            return emptyTreeVec();
            }
        -| _ ->> {
            std::ostringstream oss;
            oss << PYFORA_CONVERSION_ERROR_MESSAGE;
            throw PythonToForaConversionError(
                oss.str(),
                statement.extent()
                );
            }
    }

Expression PythonAstConverter::initializeUnboundVariablesForFunction(
        const TuplePattern& pattern,
        const Expression& inputFunctionBody
        ) const
    {
    Expression functionBody = inputFunctionBody;
    
    //look at all the variables we assign to at the root scope. If they are not bound
    //then they are 'free', but also assigned. We don't allow globals, so they'll all need
    //null let bindings
    ImmutableTreeSet<Symbol> bound = pattern.boundVariables();
    ImmutableTreeSet<Symbol> assigned = functionBody.assignedVariables();
    ImmutableTreeSet<Symbol> needingBindings = assigned - bound;

    for (auto s: needingBindings)
        functionBody = Expression::Let(
            s, 
            Expression::Constant(CSTValue(Symbol("PyforaUninitializedVariable"))),
            rebindFreeAs(functionBody, emptyTreeMap() + s + checkVariableValidityExpression(s))
            );

    return functionBody;
    }


// should only be called from convertPythonClassBodyFunctionDefToForaClassDefinitionTerm
// which does some preliminary verification 
ImmutableTreeVector<ClassDefinitionTerm> 
PythonAstConverter::convertPythonInitDefToForaClassDefinitionTerms(
        const PythonAstStatement_FunctionDefType& functionDef,
        const std::string& className
        ) const
    {
    PythonAstArguments args = functionDef.args();

    TuplePatternElement selfArg = TuplePatternElement::Normal(
        null(),
        convertPythonAstExpressionToPattern(args.args()[0]),
        null()
        );

    ImmutableTreeVector<TuplePatternElement> foraArgs = 
        computeForaArgs(dropFirstNormalArg(args));

    std::pair<
        ImmutableTreeVector<PythonAstStatement>,
        std::set<std::pair<std::string, std::string>>
        > transformedBodyAndSelfSetItemMap = rewriteSelfSetAttrs(
            selfArg,
            functionDef.body()
            );

    TuplePattern pattern = TuplePattern(foraArgs);
    Expression functionBody = 
        convertPythonAstStatementsToExpression(
            transformedBodyAndSelfSetItemMap.first
            );

    Expression createInstanceCall = 
        makeCreateInstanceCall(
            transformedBodyAndSelfSetItemMap.second,
            className
            );

    functionBody = Expression::Sequence(
        functionBody,
        createInstanceCall
        );

    functionBody = initializeUnboundVariablesForFunction(pattern, functionBody);

    ImmutableTreeVector<ClassDefinitionTerm> tr;

    for (const auto& p: transformedBodyAndSelfSetItemMap.second) 
        {
        tr = tr + ClassDefinitionTerm::DataMember(
            Symbol(publicDataMemberNameToPrivate(p.first))
            );
        tr = tr + ClassDefinitionTerm::ObjectTerm(
            noncapturingObjectMember(
                p.first,
                Expression::Variable(publicDataMemberNameToPrivate(p.first))
                )
            );
        }

    return tr + ClassDefinitionTerm::Constructor(
        Function::Term(
            pattern,
            functionBody,
            Function::Empty()
            )
        );
    }


ImmutableTreeVector<ClassDefinitionTerm>
PythonAstConverter::convertPythonClassBodyFunctionDefToForaClassDefinitionTerms(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent,
        const std::string& className
        ) const
    {
    PythonAstArguments args = functionDef.args();

    checkFunctionArgs(args, extent);

    const std::string& functionName = functionDef.name();

    ImmutableTreeVector<PythonAstExpr> decoratorList = functionDef.decorator_list();

    //check if it's @staticmethod or @property
    ImmutableTreeVector<PythonAstStatement> body = functionDef.body();
    if (decoratorList.size() > 0) {
        if (decoratorList.size() == 1 
            and decoratorList[0].isName())
            {
            const std::string& decoratorName = decoratorList[0].getName().id();

            if (decoratorName == "staticmethod") {
                return 
                    convertPythonClassBodyStaticMethodFunctionDefToForaClassDefinitionTerms(
                        functionDef,
                        extent
                        );
                }
            else if (decoratorName == "property") {
                return emptyTreeVec() +
                    convertPythonClassBodyPropertyToForaClassDefinitionTerm(
                        functionDef,
                        extent
                        );
                }                    
            }

        throw PythonToForaConversionError(
            "don't know how to convert decorator lists for functions, "
            "besides \"staticmethod\", right now",
            extent
            );
        }

    if (args.args().size() == 0)
        {
        return emptyTreeVec() + 
            createInvalidNumberOfArgumentsClassDefinitionTerm(
                functionDef.name()
                );
        }

    if (functionName == "__init__")
        {
        // should assert that there are no decorators
        if (decoratorList.size() > 0)
            throw PythonToForaConversionError(
                "don't know how to convert `__init__` methods with decorators right now",
                extent
                );
        
        return convertPythonInitDefToForaClassDefinitionTerms(functionDef, className);
        }

    Function function = 
        convertFunctionDefToForaFunction(
            functionDef,
            extent
            );

    //expose the function member as a ...(`Member, `f) { fun() {...} }
    //so that we don't capture 'f' in the class binding
    auto res = emptyTreeVec() + ClassDefinitionTerm::ObjectTerm(
        noncapturingObjectMember(
            functionName,
            Expression::Call(
                Expression::Constant(mPyBoundMethod),
                emptyTreeVec() + 
                    Expression::Variable(Symbol("@self")).normalApplyArg() + 
                    Expression::CreateFunction(
                        functionName,
                        function,
                        CSTValue()
                        ).normalApplyArg() + 
                    Expression::Constant(CSTValue(Symbol(functionName))).normalApplyArg()
                )
            )
        );
    
    return res;
    }

namespace {
    Expression constantExpressionForImplVal(const ImplValContainer& val)
        {
        return Expression::Constant(CSTValue(val));
        }
    }

Expression PythonAstConverter::convertPythonAstLambdaToFora(
                    const PythonAstArguments& arguments, 
                    const PythonAstExpr& body,
                    const SimpleParseRange& extent
                    ) const
    {
    return convertPythonAstFunctionDefToFora(
        PythonAstStatement_FunctionDefType(
            "<lambda>",
            arguments,
            emptyTreeVec() + PythonAstStatement::Return(null() << body),
            emptyTreeVec()
            ),
        extent
        );
    }

Expression PythonAstConverter::convertNullableExpressionToExpression(
        const Nullable<PythonAstExpr>& expr
        ) const
    {
    if (expr.isNull())
        return Expression::Constant(mConstantConverter->noneValue());

    return convertPythonAstExpressionToFora(*expr);
    }

Expression PythonAstConverter::convertPythonAstSliceToExpression(
        const PythonAstSlice& slice,
        const SimpleParseRange& extent
        ) const
    {
    @match PythonAstSlice(slice)
        -| Ellipsis() ->> {
            // not dealing with this just yet. we'll get to it
            std::ostringstream oss;
            oss << PYFORA_CONVERSION_ERROR_MESSAGE;
            throw PythonToForaConversionError(
                oss.str(),
                extent
                );
            }
        -| Slice(start, stop, step) ->> {
            return
                Expression::Apply(
                    Expression::Constant(
                        CSTValue(mPySliceFactory)
                        ),
                    emptyTreeVec() + 
                        ApplyArgument::Normal(
                            Expression::Constant(
                                CSTValue(Symbol("Call"))
                                )
                            ) +
                        ApplyArgument::Normal(
                            convertNullableExpressionToExpression(start)
                            ) +
                        ApplyArgument::Normal(
                            convertNullableExpressionToExpression(stop)
                            ) +
                        ApplyArgument::Normal(
                            convertNullableExpressionToExpression(step)
                            )
                    );
            }
        -| ExtSlice(slices) ->> {
            ImmutableTreeVector<ApplyArgument> tupleArgs = mapITV(
                slices,
                [this, extent](PythonAstSlice slice) {
                    return ApplyArgument::Normal(
                        convertPythonAstSliceToExpression(slice, extent)
                        );
                    }
                );

            return mPythonTupleConverter->createTupleExpression(
                Expression::CreateTuple(tupleArgs)
                );
            }
        -| Index(value) ->> {
            return convertPythonAstExpressionToFora(value);
            }
        ;
    }

Expression PythonAstConverter::wrapExpressionInPyContinueCheck(Expression e) const
    {
    return Expression::Try(
        e,
        Function::Term(
            TuplePattern(
                emptyTreeVec() + 
                    TuplePatternElement::Normal(
                        PatternWithName::Constant(CSTValue(Symbol("PyContinue")))
                        )
                ),
            Expression(),
            Function::Empty()
            ),
        null(),
        false
        );
    }

Expression PythonAstConverter::convertPythonAstExpressionToFora_inner(const PythonAstExpr& expr) const
    {
    @match PythonAstExpr(expr)
        -| Str(stdString) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertString(stdString)
                );
            }
        -| Num(Int(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertInt(value)
                );
            }
        -| Num(Long(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertLong(value)
                );
            }
        -| Num(Boolean(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertBoolean(value)
                );
            }
        -| Num(None()) ->> {
             return constantExpressionForImplVal(
                constantConverter()->noneValue()
                );
             }
        -| Num(Float(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertFloat(value)
                );
            }
        -| BoolOp(And(), exprs) ->> {
            lassert(exprs.size() > 0)

            Expression res = convertPythonAstExpressionToFora(exprs.back());

            for (long k = exprs.size() - 2; k >= 0; k--)
                {
                Symbol conditional("@conditional");

                res = Expression::Let(
                    conditional, 
                    convertPythonAstExpressionToFora(exprs[k]), 
                    Expression::Branch(
                        convertPythonAstExpressionToForaConditional(Expression::Variable(conditional)),
                        res,
                        null() << Expression::Variable(conditional)
                        )
                    );
                }

            return res;
            }
        -| BoolOp(Or(), exprs) ->> {
            lassert(exprs.size() > 0)

            Expression res = convertPythonAstExpressionToFora(exprs.back());

            for (long k = exprs.size() - 2; k >= 0; k--)
                {
                Symbol conditional("@conditional");

                res = Expression::Let(
                    conditional, 
                    convertPythonAstExpressionToFora(exprs[k]), 
                    Expression::Branch(
                        convertPythonAstExpressionToForaConditional(Expression::Variable(conditional)),
                        Expression::Variable(conditional),
                        null() << res
                        )
                    );
                }
            
            return res;
            }
        -| Attribute(value, attribute, ctx) ->> {
            Expression agent = convertPythonAstExpressionToFora(value);

            return agent.member(Symbol(attribute));
            }
        -| Subscript(value, slice, ctx) ->> {
            Expression valueGetItemMemberFunction = 
                Expression::Member(
                    convertPythonAstExpressionToFora(value),
                    Symbol("__getitem__"),
                    1
                    );

            auto sliceArg =
                ApplyArgument::Normal(
                    convertPythonAstSliceToExpression(slice, expr.extent())
                    );

            return Expression::Call(
                valueGetItemMemberFunction,
                emptyTreeVec() + sliceArg
                );
            }
        -| GeneratorExp(expr, generators) ->> {
            lassert(generators.size());

            /************************************
            generator-expressions get transformed as follows: 
            
                (expr for pat in generator if filterExpr)
            
            becomes

                generator.__pyfora_generator__().filter(lambda pat: filterExpr).map(lambda pat: expr)

            with nested iterators, we have
                
                (expr1 for pat1 in generator if filtExpr for pat2 in sub_generator if filtExpr2) 

            becoming

                generator
                    .__pyfora_generator__()
                    .filter(lambda pat1: filtExpr)
                    .nest(lambda pat1: 
                        sub_generator
                            .__pyfora_generator__()
                            .filter(lambda pat2: filtExpr2)
                            .map(lambda pat2: expr)
                        )

            ***********************************/
            
            Nullable<Expression> accumulator;

            for (long genIx = generators.size() - 1; genIx >= 0; genIx--)
                {
                Expression generator = 
                    convertPythonAstExpressionToFora(generators[genIx].iter())
                        .member(Symbol("__pyfora_generator__"))();

                for (auto c: generators[genIx].conditions())
                    generator = generator.member(Symbol("filter"))(
                        convertPythonAstExpressionToFora(
                            PythonAstExpr::Lambda(
                                PythonAstArguments(
                                    emptyTreeVec() + generators[genIx].target(),
                                    null(),
                                    null(),
                                    emptyTreeVec()
                                    ),
                                c
                                )
                            )
                        );

                //the first time in the loop, we are calculating the 
                if (!accumulator)
                    accumulator = generator.member(Symbol("map"))(
                        convertPythonAstExpressionToFora(
                            PythonAstExpr::Lambda(
                                PythonAstArguments(
                                    emptyTreeVec() + generators[genIx].target(),
                                    null(),
                                    null(),
                                    emptyTreeVec()
                                    ),
                                expr
                                )
                            )
                        );
                else
                    accumulator = generator.member(Symbol("nest"))(
                        createObjectImplementingCallOperatorForFunction(
                            Function::Term(
                                TuplePattern(
                                    emptyTreeVec() + 
                                        TuplePatternElement::Normal(
                                            convertPythonAstExpressionToPattern(generators[genIx].target())
                                            )
                                    ),
                                *accumulator,
                                Function::Empty()
                                ),
                            "<lambda>",
                            null()
                            )
                        );
                }
            
            return *accumulator;
            }
        -| ListComp(elt, generators) ->> {
            ImmutableTreeSet<Symbol> assigned;
            for (auto gen: generators)
                assigned = assigned + convertPythonAstExpressionToPattern(
                    gen.target()
                    ).boundVariables();

            auto res = 
                Expression::Constant(mPyListType)(
                    convertPythonAstExpressionToFora(
                        PythonAstExpr::GeneratorExp(elt, generators)
                        )
                    );

            for (auto var: assigned)
                res = Expression::Sequence(
                    Expression::Assign(
                        PatternWithName::Anything(null() << var),
                        Expression::Constant(CSTValue(Symbol("PyforaInvalidVariable")))
                        ),
                    res
                    );

            return res;
            }
        -| List(elts) ->> {
            return mPythonListConverter->convertPyList(
                expr.getList(),
                boost::bind(
                    &PythonAstConverter::convertPythonAstExpressionToFora,
                    this, 
                    _1
                    )
                );
            }
        -| Dict(elts) ->> {
            return mPythonDictConverter->convertPyDict(
                expr.getDict(),
                boost::bind(
                    &PythonAstConverter::convertPythonAstExpressionToFora,
                    this, 
                    _1
                    )
                );
            }
        -| DictComp(key, value, generators) ->> {
            PythonAstExpr pyUpdateSequence = 
                PythonAstExpr::ListComp(
                    PythonAstExpr::Tuple(
                        emptyTreeVec() + key + value,
                        PythonAstExprContext::Load()
                        ),
                    generators
                    );

            Expression foraUpdateSequence =
                convertPythonAstExpressionToFora(
                    pyUpdateSequence
                    );
        
            return Expression::Call(
                Expression::Constant(
                    mPyDictType
                    ),
                emptyTreeVec() +
                foraUpdateSequence.normalApplyArg()
                );
            }
        -| Tuple(elts) ->> {
            return mPythonTupleConverter->convertPyTuple(
                expr.getTuple(),
                boost::bind(
                    &PythonAstConverter::convertPythonAstExpressionToFora,
                    this,
                    _1
                    )
                );
            }
        -| UnaryOp(op, rhs) ->> {
            Symbol opAsSymbol;
            
            @match PythonAstUnaryOp(op)
                -| Invert() ->> { opAsSymbol = Symbol("~"); }
                -| Not() ->> { opAsSymbol = Symbol("!"); }
                -| UAdd() ->> { opAsSymbol = Symbol("+"); }
                -| USub() ->> { opAsSymbol = Symbol("-"); }
                ;

            return Expression::LeftOperator(
                opAsSymbol,
                convertPythonAstExpressionToFora(rhs)
                );
            }
        -| BinOp(lhs, Add(), List(Leaf(elt, Empty()))) ->> {
            Expression convertedLhs = convertPythonAstExpressionToFora(lhs);
            Expression convertedElt = convertPythonAstExpressionToFora(elt);

            return mPythonListConverter->concatSingleEltVectorExpr(
                convertedLhs, convertedElt
                );
            }
        -| BinOp(lhs, op, rhs) ->> {
            Symbol opAsSymbol;
            
            @match PythonAstBinaryOp(op)
                -| Add() ->> { opAsSymbol = Symbol("+"); }
                -| Sub() ->> { opAsSymbol = Symbol("-"); }
                -| Mult() ->> { opAsSymbol = Symbol("*"); }
                -| Div() ->> { opAsSymbol = Symbol("/"); }
                -| Mod() ->> { opAsSymbol = Symbol("%"); }
                -| Pow() ->> { opAsSymbol = Symbol("**"); }
                -| LShift() ->> { opAsSymbol = Symbol("<<"); }
                -| RShift() ->> { opAsSymbol = Symbol(">>"); }
                -| BitOr() ->> { opAsSymbol = Symbol("|"); }
                -| BitXor() ->> { opAsSymbol = Symbol("^"); }
                -| BitAnd() ->> { opAsSymbol = Symbol("&"); }
                -| FloorDiv() ->> { opAsSymbol = Symbol("//"); }
                ;

            return Expression::BinaryOperator(
                convertPythonAstExpressionToFora(lhs),
                opAsSymbol,
                convertPythonAstExpressionToFora(rhs)
                );
            }
        -| Lambda(arguments, body) ->> {
            return convertPythonAstLambdaToFora(arguments, body, expr.extent());
            }
        -| IfExp(cond, ifTrue, ifFalse) ->> {
            return Expression::Branch(
                convertPythonAstExpressionToForaConditional(cond),
                convertPythonAstExpressionToFora(ifTrue),
                null() << convertPythonAstExpressionToFora(ifFalse)
                );
            }
        -| Repr(expr) ->> {
            return Expression::Call(
                Expression::Constant(CSTValue(Symbol("ParsableRepresentation"))),
                emptyTreeVec() + 
                    ApplyArgument::Normal(
                        convertPythonAstExpressionToFora(expr)
                        )
                );
            }
        -| Compare(expr, comparisons, comparisonExprs) ->> {
            if (comparisons.size() != comparisonExprs.size())
                throw PythonToForaConversionError(
                    "valid python should have an equal number of comparison operators and expressions",
                    expr.extent()
                    );

            if (comparisons.size() != 1)
                throw PythonToForaConversionError(
                    "don't know how to convert chained comparisons yet.",
                    expr.extent()
                    );

            Expression curExpr = convertPythonAstExpressionToFora(expr);
            Expression result;

            for (long k = 0; k < comparisons.size(); k++)
                {
                Expression curRhs = convertPythonAstExpressionToFora(comparisonExprs[k]);

                Expression toAdd;

                @match PythonAstComparisonOp(comparisons[k])
                    -| Eq() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("=="), curRhs); }
                    -| NotEq() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("!="), curRhs); }
                    -| Lt() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("<"), curRhs); }
                    -| LtE() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("<="), curRhs); }
                    -| Gt() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol(">"), curRhs); }
                    -| GtE() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol(">="), curRhs); }
                    -| Is() ->> { 
                        toAdd = Expression::Branch(
                            Expression::Is(curExpr, curRhs), 
                            Expression::Constant(mConstantConverter->convertBoolean(true)), 
                            null() << Expression::Constant(mConstantConverter->convertBoolean(false))
                            ); 
                        }
                    -| IsNot() ->> {
                        toAdd = Expression::Branch(
                            Expression::IsNot(curExpr, curRhs), 
                            Expression::Constant(mConstantConverter->convertBoolean(true)), 
                            null() << Expression::Constant(mConstantConverter->convertBoolean(false))
                            ); 
                        }
                    -| In() ->> { toAdd = Expression::In(curExpr, curRhs); }
                    -| NotIn() ->> { toAdd = Expression::NotIn(curExpr, curRhs); }
                    ;

                if (k == 0)
                    result = toAdd;
                else
                    result = Expression::And(result, toAdd);
                }

            return result;
            }
        -| Yield(e) ->> {
            return
                Expression::Continuation(
                    Function::Term(
                        TuplePattern(emptyTreeVec() +
                            TuplePatternElement::Normal(
                                PatternWithName::Anything(null() << Symbol("@continuation"))
                                )
                            ),
                        Expression::Return(
                            Expression::CreateTuple(
                                emptyTreeVec() + 
                                    ApplyArgument::Normal(
                                        e ? convertPythonAstExpressionToFora(*e) : Expression()
                                        ) +
                                    ApplyArgument::Normal(Expression::Variable(Symbol("@continuation")))
                                )
                            ),
                    Function::Empty()
                    )
                );
            }
        -| Call(func, args, kwds, starArgs, kwargs) ->> {
            if (starArgs.isValue())
                throw PythonToForaConversionError(
                    "don't know how to convert starArgs just yet.",
                    expr.extent()
                    );

            if (kwargs.isValue())
                throw PythonToForaConversionError(
                    "don't know how to convert kwargs just yet.",
                    expr.extent()
                    );

            if (kwds.size() > 0)
                throw PythonToForaConversionError(
                    "don't know how to convert keywords just yet.",
                    expr.extent()
                    );

            return Expression::Call(
                convertPythonAstExpressionToFora(func),
                mapITV(args, [this](PythonAstExpr expr) {
                    return ApplyArgument::Normal(
                        convertPythonAstExpressionToFora(expr)
                        );
                    })
                );
            }
        -| Name(identifier, Load()) ->> {
            //when loading variables, we need to check whether they are specific symbols
            //that we use to denote states like 'uninitialized' or 'invalid'. If so, we defer
            //to a member of the PyObjectBase to figure out what to do
            return Expression::Variable(Symbol(identifier));
            }
        -| _ ->> {
            }

    std::ostringstream oss;
    oss << PYFORA_CONVERSION_ERROR_MESSAGE;
    throw PythonToForaConversionError(
        oss.str(),
        expr.extent()
        );
    }

Expression PythonAstConverter::convertPythonAstExpressionToForaConditional(const Expression& expr) const
    {
    //we need to convert this to a bool, which we do by calling PyBool (or equivalent as given)
    //and then calling 'Bool' on that
    return Expression::Apply(expr, 
            emptyTreeVec() 
                + ApplyArgument::Normal(Expression::Constant(CSTValue(Symbol("Convert"))))
                + ApplyArgument::Normal(Expression::Constant(CSTValue(JOV::OfType(Type::Integer(1,false)))))
            );
    }

Expression PythonAstConverter::convertPythonAstExpressionToForaConditional(const PythonAstExpr& expr) const
    {
    Expression tr = convertPythonAstExpressionToFora(expr);

    return convertPythonAstExpressionToForaConditional(tr);
    }


Expression PythonAstConverter::convertPythonAstExpressionToFora(const PythonAstExpr& expr) const
    {
    Expression tr = convertPythonAstExpressionToFora_inner(expr);

    return CPPML::replaceCommonData(
        tr,
        ExpressionLocationMetadata::WithSimpleParseRange(expr.extent())
        );
    }

Expression PythonAstConverter::convertPythonAstStatementsToExpression(
        const ImmutableTreeVector<PythonAstStatement>& statements
        ) const
    {
    Expression result;

    for (auto s: statements)
        result = Expression::Sequence(result, convertPythonAstStatementToExpression(s));

    return result;
    }

Function PythonAstConverter::convertPythonAstExceptionHandlers(
        const ImmutableTreeVector<PythonAstExceptionHandler>& handlers
        ) const
    {
    if (handlers.size() == 0)
        return Function::Empty();

    Function tail = convertPythonAstExceptionHandlers(handlers.slice(1));

    PatternWithName pattern = PatternWithName::Anything(null());

    if (handlers[0].name())
        pattern = convertPythonAstExpressionToPattern(*handlers[0].name());

    if (handlers[0].type().isValue())
        {
        Expression e = convertPythonAstExpressionToFora(*handlers[0].type());

        pattern.pattern() = 
            Pattern::MatchBoth(
                pattern.pattern(), 
                Pattern::ExpressionMatch(
                    e,
                    TuplePattern(emptyTreeVec() + TuplePatternElement::VarArgs(null()))
                    )
                );
        }

    //augment the pattern to insist that it also matches 'PyforaException'
    pattern.pattern() = 
        Pattern::MatchBoth(
            pattern.pattern(), 
            Pattern::ExpressionMatch(
                Expression::Constant(CSTValue(Symbol("PyforaException"))),
                TuplePattern(emptyTreeVec() + TuplePatternElement::VarArgs(null()))
                )
            );

    TuplePattern pat = TuplePattern(
        emptyTreeVec() + TuplePatternElement::Normal(
            null(),
            pattern,
            null()
            )
        );

    return Function::Term(
        pat, 
        convertPythonAstStatementsToExpression(handlers[0].body()),
        tail
        );
    }

Expression PythonAstConverter::convertPythonAstStatementToExpression_inner(
        const PythonAstStatement& statement
        ) const
    {
    @match PythonAstStatement(statement)
        -| FunctionDef(name) ->> {
            return Expression::Assign(
                PatternWithName::Anything(null() << Symbol(name)),
                convertPythonAstFunctionDefToFora(
                    statement.getFunctionDef(),
                    statement.extent()
                    )
                );
            }
        -| ClassDef(name, bases, body, decoratorList) ->> {
            return Expression::Assign(
                PatternWithName::Anything(null() << Symbol(name)),
                convertPythonAstClassDefToFora(
                    statement.getClassDef(),
                    statement.extent()
                    )
                );
            }
        -| Return(Null()) ->> {
            return Expression::Return(Expression::Constant(mConstantConverter->noneValue()));
            }
        -| Return(Value(e)) ->> {
            return Expression::Return(convertPythonAstExpressionToFora(e));
            }
        -| Pass() ->> { return Expression::Constant(mConstantConverter->noneValue()); }
        -| Break() ->> { return Expression::Break(); }
        -| Continue() ->> { return Expression::Throw(Expression::Constant(CSTValue(Symbol("PyContinue"))), null()); }
        -| Raise(type, inst, tback) ->> {
            if (type && !inst && !tback)
                {   
                return Expression::Throw(
                    convertPythonAstExpressionToFora(*type),
                    Nullable<Expression>()
                    ); 
                }
            else
                throw PythonToForaConversionError(
                    "We only support 'raise' with a single argument",
                    statement.extent()
                    );
            }
        -| Expr(e) ->> {
            return convertPythonAstExpressionToFora(e);
            }
        -| For(target, iter, body, orelse) ->> {

            Expression leafExpr = 
                wrapExpressionInPyContinueCheck(
                    convertPythonAstStatementsToExpression(body)
                    );
                
            Symbol var = freshVarname(Symbol("@"), mentionedVariables(leafExpr));

            return Expression::Sequence(
                Expression::Foreach(
                    ListComprehensionChain::Term(
                        PatternWithName::Anything(null() << var),
                        null(),
                        convertPythonAstExpressionToFora(iter),
                        ListComprehensionChain::Leaf(
                            Expression::Sequence(
                                Expression::Assign(
                                    convertPythonAstExpressionToPattern(target),
                                    Expression::Variable(var)
                                    ),
                                leafExpr
                                )
                            )
                        )
                    ),
                convertPythonAstStatementsToExpression(orelse)
                );
            }
        -| While(cond, ifTrue, ifFalse) ->> {
            return Expression::Sequence(
                Expression::While(
                    convertPythonAstExpressionToForaConditional(cond),
                    wrapExpressionInPyContinueCheck(convertPythonAstStatementsToExpression(ifTrue))
                    ),
                convertPythonAstStatementsToExpression(ifFalse)
                );
            }
        -| If(cond, ifTrue, ifFalse) ->> {
            return Expression::Branch(
                convertPythonAstExpressionToForaConditional(cond),
                convertPythonAstStatementsToExpression(ifTrue),
                null() << convertPythonAstStatementsToExpression(ifFalse)
                );
            }
        -| TryExcept(body, handlers, orelse) ->> {
            if (orelse.size() > 0)
                throw PythonToForaConversionError(
                    "don't know how to convert else clauses in try statements",
                    statement.extent()
                    );

            return Expression::Try(
                convertPythonAstStatementsToExpression(body),
                convertPythonAstExceptionHandlers(
                    handlers
                    ),
                null(),
                false
                );
            }
        -| Assign(exprs, expression) ->> {
            if (exprs.size() == 0)
                throw PythonToForaConversionError(
                    "valid python expressions should have a left hand side",
                    statement.extent()
                    );
            if (exprs.size() == 1)
                return Expression::Assign(
                    convertPythonAstExpressionToPattern(exprs[0]),
                    convertPythonAstExpressionToFora(expression)
                    );
            else
                return Expression::Assign(
                    PatternWithName(
                        Pattern::Tuple(
                            TuplePattern(
                                mapITV(exprs, [this](PythonAstExpr ex) {
                                    return TuplePatternElement::Normal(
                                        null(),
                                        convertPythonAstExpressionToPattern(ex),
                                        null()
                                        );
                                    })
                                )
                            ),
                        null(),
                        null(),
                        ExpressionLocationMetadata()
                        ),
                    convertPythonAstExpressionToFora(expression)
                    );
            }
        -| _ ->> {
            std::ostringstream oss;
            oss << PYFORA_CONVERSION_ERROR_MESSAGE;
            throw PythonToForaConversionError(
                oss.str(),
                statement.extent()
                );
            }
    }

Expression PythonAstConverter::convertPythonAstStatementToExpression(
        const PythonAstStatement& statement
        ) const
    {
    Expression tr = convertPythonAstStatementToExpression_inner(statement);

    return CPPML::replaceCommonData(
        tr,
        ExpressionLocationMetadata::WithSimpleParseRange(
            statement.extent()
            )
        );
    }

PatternWithName PythonAstConverter::convertPythonAstExpressionToPattern_inner(
        const PythonAstExpr& expr
        ) const
    {
    @match PythonAstExpr(expr)
        -| Name(n, Param()) ->> {
            return PatternWithName::Anything(null() << Symbol(n));
            }
        -| Name(n, Store()) ->> {
            return PatternWithName::Anything(null() << Symbol(n));
            }
        -| Tuple(elts, Store()) ->> {
            return PatternWithName(
                Pattern::ExpressionMatch(
                    Expression::Constant(
                        CSTValue::Tuple(
                            emptyTreeVec() + 
                                CSTValue::Tag(Symbol("TupleAssign")) + 
                                CSTValue((int64_t)elts.size())
                            )
                        ),
                    TuplePattern(
                        mapITV(elts, [&](PythonAstExpr e) {
                            return TuplePatternElement::Normal(
                                convertPythonAstExpressionToPattern(e)
                                );
                            })
                        )
                    ),
                null(),
                null(), 
                ExpressionLocationMetadata::WithSimpleParseRange(expr.extent())
                );
            }
        -| _ ->> {
            std::ostringstream oss;
            oss << PYFORA_CONVERSION_ERROR_MESSAGE;
            throw PythonToForaConversionError(
                oss.str(),
                expr.extent()
                );
            }
    }

PatternWithName PythonAstConverter::convertPythonAstExpressionToPattern(
        const PythonAstExpr& expr
        ) const
    {
    PatternWithName tr = convertPythonAstExpressionToPattern_inner(expr);

    return PatternWithName(
        tr.pattern(),
        tr.name(),
        tr.condition(),
        ExpressionLocationMetadata::WithSimpleParseRange(
            expr.extent()
            )
        );
    }

Expression PythonAstConverter::convertPythonAstClassDefToFora(
        const PythonAstStatement_ClassDefType& classDef,
        const SimpleParseRange& extent
        ) const
    {
    const std::string& className = classDef.name();
    ImmutableTreeVector<PythonAstExpr> bases = classDef.bases();
    ImmutableTreeVector<PythonAstStatement> body = classDef.body();
    ImmutableTreeVector<PythonAstExpr> decoratorList = classDef.decorator_list();

    if (decoratorList.size() > 0) {
        throw PythonToForaConversionError(
            "don't know how to convert decorator lists for classes right now",
            extent
            );
        }

    if (bases.size() > 0) {
        throw PythonToForaConversionError(
            "don't know how to deal with base classes right now",
            extent
            );
        }

    ImmutableTreeVector<ClassDefinitionTerm> classDefinitionTerms;

    for (const auto& statement: body) {
        classDefinitionTerms = classDefinitionTerms +
            convertPythonClassBodyStatementToForaClassDefinitionTerms(
                statement,
                className
                );
        }
        
    classDefinitionTerms = classDefinitionTerms + 
        ClassDefinitionTerm::ObjectTerm(
            ObjectDefinitionTerm::Member(
                Symbol("__class__"),
                Expression::Variable(Symbol(className)),
                1
                )
            );

    if (mPyObjectBaseMixin.type().isClass())
        {
        classDefinitionTerms = classDefinitionTerms + 
            ClassDefinitionTerm::ObjectTerm(
                ObjectDefinitionTerm::Mixin(
                    Expression::Constant(
                        CSTValue(mPyObjectBaseMixin)
                        )
                    )
                );

        //the class object itself is also a PyObject
        classDefinitionTerms = classDefinitionTerms + 
            ClassDefinitionTerm::Static(
                ObjectDefinitionTerm::Mixin(
                    Expression::Constant(
                        CSTValue(mPyObjectBaseMixin)
                        )
                    )
                );
        }
    else
        lassert_dump(
            mPyObjectBaseMixin.type().isNothing(), 
            "pyObjectBaseMixin must be 'nothing' or an object"
            );

    ClassDefinitionBody classDefinitionBody = ClassDefinitionBody::Empty();

    for (long k = (long)classDefinitionTerms.size() - 1; k >= 0; k--)
        classDefinitionBody = ClassDefinitionBody::Term(
            ClassDefinitionTermWithMetadata(
                classDefinitionTerms[k],
                CSTValue()
                ),
            classDefinitionBody
            );

    return Expression::CreateClass(
        className, 
        ClassDefinition(
            classDefinitionBody,
            null() << Symbol(className),
            null() << Symbol("@self"),
            ExpressionLocationMetadata::WithSimpleParseRange(extent)
            ),
        CSTValue()
        );
    }

Function PythonAstConverter::convertFunctionDefToForaFunction(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    std::pair<Expression, TuplePattern> functionBodyAndPattern = 
        convertFunctionDefToForaFunctionBodyAndPattern(
            functionDef,
            extent
            );

    Expression functionBody = initializeUnboundVariablesForFunction(
        functionBodyAndPattern.second,
        functionBodyAndPattern.first
        );

    if (hasYield(functionDef))
        functionBody = 
            Expression::Call(
                Expression::Constant(mPyGeneratorFactory),
                emptyTreeVec() + 
                    Expression::CreateFunction(
                        "<generator>",
                        Function::Term(TuplePattern(), functionBody, Function::Empty()),
                        CSTValue()
                        ).normalApplyArg()
                );

    return Function::Term(
        functionBodyAndPattern.second,
        functionBody,
        invalidCallHandler(
            functionDef.name(),
            functionBodyAndPattern.second
            )
        );
    }

Expression PythonAstConverter::checkVariableValidityExpression(Symbol s) const
    {  
    return Expression::Try(
        Expression::Sequence(
            Expression::Apply(
                Expression::Constant(CSTValue(Symbol("CheckValueIsPyforaInvalidVariableSymbol"))),
                emptyTreeVec() + 
                    ApplyArgument::Normal(Expression::Variable(Symbol(s)))
                ),
            Expression::Variable(Symbol(s))
            ),
        Function::Term(
            TuplePattern(
                emptyTreeVec() + 
                    TuplePatternElement::VarArgs(null())
                ),
            Expression::Constant(CSTValue(mPyObjectBaseMixin))
            .member(Symbol("__pyfora_invalid_variable_access__"))(
                Expression::Variable(Symbol(s)), 
                Expression::Constant(CSTValue(Symbol(s)))
                ),
            Function::Empty()
            ),
        null(),
        false
        );
    }
    
std::pair<Expression, TuplePattern> 
PythonAstConverter::convertFunctionDefToForaFunctionBodyAndPattern(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    const std::string& functionName = functionDef.name();
    PythonAstArguments args = functionDef.args();
    ImmutableTreeVector<PythonAstStatement> body = functionDef.body();
    
    ImmutableTreeVector<PythonAstExpr> decoratorList = functionDef.decorator_list();

    if (decoratorList.size() > 0) {
        throw PythonToForaConversionError(
            "don't know how to convert decorator lists for functions right now",
            extent
            );
        }

    checkFunctionArgs(args, extent);

    ImmutableTreeVector<TuplePatternElement> foraArgs = computeForaArgs(args);
    TuplePattern pattern = TuplePattern(foraArgs);
    Expression functionBody = convertPythonAstStatementsToExpression(body);

    functionBody = Expression::Sequence(
        functionBody,
        Expression::Return(
            Expression::Constant(
                mConstantConverter->noneValue()
                )
            )
        );

    return std::make_pair(functionBody, pattern);
    }

Expression PythonAstConverter::addWithBlockReturnStatement(
                Expression expr, 
                ImmutableTreeVector<std::string> assigned
                ) const
    {
    return Expression::Sequence(
        expr,
        Expression::Return(
            mPythonTupleConverter->createTupleExpression(
                Expression::CreateTuple(
                    emptyTreeVec() +
                    ApplyArgument::Normal(
                        null(),
                        getDictOfAssignedVariables(assigned)
                        ) +
                    ApplyArgument::Normal(
                        null(),
                        constantExpressionForImplVal(
                            constantConverter()->convertInt(0)
                            )
                        ) +
                    ApplyArgument::Normal(
                        null(),
                        constantExpressionForImplVal(
                            constantConverter()->convertInt(0)
                            )
                        )
                    )
                )
            )
        );
    }

Expression PythonAstConverter::convertPythonAstWithBlockFunctionDefToFora(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent,
        ImmutableTreeVector<std::string> varsToConsiderFree
        ) const
    {
    ImmutableTreeSet<Symbol> varsToConsiderFreeSet;

    for (auto v: varsToConsiderFree)
        varsToConsiderFreeSet = varsToConsiderFreeSet + Symbol(v);

    const std::string& functionName = functionDef.name();

    std::pair<Expression, TuplePattern> functionBodyAndPattern = 
        convertFunctionDefToForaFunctionBodyAndPattern(
            functionDef,
            extent
            );

    ImmutableTreeVector<std::string> assigned;
    for (auto var: functionBodyAndPattern.first.assignedVariables())
        if (var.toString()[0] != '@')
            assigned = assigned + var.toString();

    @match Expression(functionBodyAndPattern.first)
        -| Sequence(inner, Return(Constant(shouldBeNone))) ->> {
            lassert(shouldBeNone == CSTValue(mConstantConverter->noneValue()));

            functionBodyAndPattern.first = inner;
            }

    Expression functionBody = functionBodyAndPattern.first;

    ImmutableTreeSet<Symbol> freeVarsToCheck = functionBody.freeVariables();

    for (auto s: freeVarsToCheck)
        if (!varsToConsiderFreeSet.contains(s))
            functionBody = rebindFreeAs(functionBody, emptyTreeMap() + s + checkVariableValidityExpression(s));

    functionBody = wrapWithBlockFunctionBodyInTryCatch(
        functionBody,
        assigned
        );

    functionBody = 
        addWithBlockReturnStatement(functionBody, assigned);
    
    for (auto s: freeVarsToCheck)
        if (!varsToConsiderFreeSet.contains(s))
            functionBody = Expression::Let(
                s, 
                Expression::Constant(CSTValue(Symbol("PyforaUninitializedVariable"))),
                functionBody
                );

    Function function = Function::Term(
        functionBodyAndPattern.second,
        functionBody,
        Function::Empty()
        );

    return createObjectImplementingCallOperatorForFunction(
        function,
        functionName,
        null() << extent
        );
    }

Expression PythonAstConverter::getDictOfAssignedVariables(
        const ImmutableTreeVector<std::string>& assignedVariables
        ) const
    {
    ImmutableTreeVector<Expression> keys;
    ImmutableTreeVector<Expression> values;

    for (const auto& name: assignedVariables)
        {
        keys = keys + Expression::Constant(
            CSTValue(
                mConstantConverter->convertString(name)
                )
            );
        values = values + Expression::Variable(
            Symbol(name)
            );
        }

    return mPythonDictConverter->createDictExpr(
        keys,
        values
        );
    }

Expression PythonAstConverter::wrapWithBlockFunctionBodyInTryCatch(
        const Expression& functionBody,
        const ImmutableTreeVector<std::string>& assignedVariables
        ) const
    {
    Symbol catchVar = freshVarname(
        "exception_var",
        mentionedVariables(
            functionBody
            )
        );

    // TODO not dealing with intermediate assigned variables yet

    Symbol stacktraceVar = Symbol("@stacktrace");

    Function catchFun = 
        Function::Term(
            TuplePattern(
                emptyTreeVec() +
                    TuplePatternElement::Normal(
                        null(),
                        PatternWithName(
                            Pattern::Anything(),
                            null() << catchVar,
                            null(),
                            ExpressionLocationMetadata::Empty()
                            ),
                        null()
                        )
                ),
            Expression::Return(
                mPythonTupleConverter->createTupleExpression(
                    Expression::CreateTuple(
                        emptyTreeVec() +
                        ApplyArgument::Normal(
                            null(),
                            getDictOfAssignedVariables(assignedVariables)
                            ) +
                        ApplyArgument::Normal(
                            null(),
                            Expression::Variable(
                                stacktraceVar
                                )
                            ) +
                        ApplyArgument::Normal(
                            null(),
                            Expression::Variable(catchVar)
                            )
                        )
                    )
                ),
            Function::Empty()
            );

    return Expression::Try(
        functionBody,
        catchFun,
        null() << stacktraceVar,
        false
        );        
    }

Expression PythonAstConverter::convertPythonAstFunctionDefToFora(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    const std::string& functionName = functionDef.name();

    Function function = convertFunctionDefToForaFunction(
        functionDef,
        extent
        );

    return createObjectImplementingCallOperatorForFunction(
        function,
        functionName,
        null() << extent
        );
    }

Expression PythonAstConverter::createObjectImplementingCallOperatorForFunction(
        const Function& function,
        const std::string& functionName,
        Nullable<SimpleParseRange> extent
        ) const
    {
    return Expression::CreateObject(
        functionName,
        ObjectDefinition(
            ObjectDefinitionBody::Term(
                ObjectDefinitionTermWithMetadata(
                    ObjectDefinitionTerm::Call(
                        function
                        ),
                    CSTValue()
                    ),
                mPyObjectBaseMixin.type().isClass() ? 
                    ObjectDefinitionBody::Term(
                        ObjectDefinitionTermWithMetadata(
                            ObjectDefinitionTerm::Mixin(
                                Expression::Constant(
                                    CSTValue(mPyObjectBaseMixin)
                                    )
                                ),
                            CSTValue()
                            ),
                        ObjectDefinitionBody::Empty()
                        ) 
                :   ObjectDefinitionBody::Empty()
                ),
            null() << Symbol(functionName),
            extent ? 
                ExpressionLocationMetadata::WithSimpleParseRange(*extent)
            :   ExpressionLocationMetadata::Empty()
            ),
        CSTValue()
        );
    }


/*
Called from convertPythonClassBodyFunctionDefToForaClassDefinitionTerm which verifies
expected properties on `args`
*/
ImmutableTreeVector<ClassDefinitionTerm>
PythonAstConverter::convertPythonClassBodyStaticMethodFunctionDefToForaClassDefinitionTerms(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    PythonAstStatement_FunctionDefType functionDefWithoutDecorators = functionDef;
    functionDefWithoutDecorators.decorator_list() = emptyTreeVec();

    Function function = 
        convertFunctionDefToForaFunction(
            functionDefWithoutDecorators,
            extent
            );

    return emptyTreeVec() + 
        ClassDefinitionTerm::Static(
            noncapturingObjectMember(
                functionDef.name(),
                createObjectImplementingCallOperatorForFunction(
                    function,
                    functionDef.name(),
                    null() << extent
                    )
                )
            ) + 
        ClassDefinitionTerm::ObjectTerm(
            noncapturingObjectMember(
                functionDef.name(),
                createObjectImplementingCallOperatorForFunction(
                    function,
                    functionDef.name(),
                    null() << extent
                    )
                )
            );
    }

/*
Called from convertPythonClassBodyFunctionDefToForaClassDefinitionTerm which verifies
expected properties on `args`
*/
ClassDefinitionTerm 
PythonAstConverter::convertPythonClassBodyPropertyToForaClassDefinitionTerm(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    PythonAstStatement_FunctionDefType functionDefWithoutDecorators = functionDef;
    functionDefWithoutDecorators.decorator_list() = emptyTreeVec();

    Function function = 
        convertFunctionDefToForaFunction(
            functionDefWithoutDecorators,
            extent
            );

    return ClassDefinitionTerm::ObjectTerm(
        ObjectDefinitionTerm::Anything(
            Function::Term(
                TuplePattern(
                    emptyTreeVec() + 
                        TuplePatternElement::Normal(
                            PatternWithName::Constant(CSTValue(Symbol("Member")))
                            ) +
                    TuplePatternElement::Normal(
                        PatternWithName::Constant(CSTValue(Symbol(functionDef.name())))
                        )
                    ),
                Expression::Call(
                    Expression::Call(
                        Expression::Constant(mPyBoundMethod),
                        emptyTreeVec() +
                        Expression::Variable(Symbol("@self")).normalApplyArg() +
                        Expression::CreateFunction(
                            "__property_fun",
                            function,
                            CSTValue()
                            ).normalApplyArg() +
                        Expression::Constant(
                            CSTValue(Symbol(functionDef.name()))
                            ).normalApplyArg()
                        ),
                    emptyTreeVec()
                    ),                
                Function::Empty()
                )
            )
        );
    }


ImmutableTreeVector<TuplePatternElement> PythonAstConverter::computeForaArgs(
        const PythonAstArguments& pythonArgs
        ) const
    {
    ImmutableTreeVector<TuplePatternElement> foraArgs;

    int defaultArgCount = pythonArgs.defaults().size();
    int totalArgumentCount = pythonArgs.args().size();
    int nonDefaultArgCount = totalArgumentCount - defaultArgCount;
    for (long k = 0; k < nonDefaultArgCount; k++)
        foraArgs = foraArgs + TuplePatternElement::Normal(
            null(),
            convertPythonAstExpressionToPattern(pythonArgs.args()[k]),
            null()
            );
    int idx = 0;
    for (long k = nonDefaultArgCount; k < totalArgumentCount; k++)
        foraArgs = foraArgs + TuplePatternElement::Normal(
            null(),
            convertPythonAstExpressionToPattern(pythonArgs.args()[k]),
            null() << convertPythonAstExpressionToFora(pythonArgs.defaults()[idx++])
            );

    return foraArgs;
    }

}


