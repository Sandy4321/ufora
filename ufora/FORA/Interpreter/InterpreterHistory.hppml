/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#pragma once

#include "../../core/math/Nullable.hpp"
#include <boost/shared_ptr.hpp>
#include <boost/function.hpp>

class NativeRuntimeCallTarget;

template<int count>
class NativeRuntimeContinuationValue;

class NativeRuntimeContinuationBase;

class NativeRuntimeContinuationValueVector;

class JudgmentOnValue;

namespace Fora {

class InterpreterTraceTerm;

}

namespace TypedFora {

class TypedJumpTarget;
class Type;

}

namespace Fora {
namespace Interpreter {

class Instruction;

class InterpreterHistoryImpl;

class EvalFrame;

class ExecutionContextConfiguration;

//keeps track of the history of a given thread's events within
//the interpreter. There is one of these for each ExecutionContext.

class InterpreterHistory {
public:
	InterpreterHistory(boost::shared_ptr<ExecutionContextConfiguration> inConfig);

	bool isTracing() const;

	double timeOfLastTraceEvent();

	void clear();

	void pause();

	void resume();

	//the interpreter is executing an instruction here
	void onInterpreterStep(EvalFrame* inInstruction);

	//the interpreter is returning a result to a native caller and exiting
	void onFollowingTypedNativeContinuation(
					const NativeRuntimeContinuationValue<1>& continuation,
					const JudgmentOnValue& inResultJOV,
					bool isException
					);

	//the interpreter tried to return to native code, but the native code couldn't handle the
	//value we handed it, so we immediately transferred to the interpreter
	void onReturnToNativeCodeButImmediatelyTransferToInterpreter();

	//the interpreter is transferring into native code
	void onTransferToNativeCode(EvalFrame* inEvalFrame,
								const TypedFora::TypedJumpTarget& inTarget
								);

	void continuationAdapterFollowed(bool isException, TypedFora::Type type, bool isTargetNative);

	void onTransferToInterpreterFromNativeCode(const NativeRuntimeContinuationBase& continuation);

	void onInterpreterResumedWithoutValue(EvalFrame* inEvalFrame);

	void onArbitraryInterpreterLogging(std::string msg);

	void onInterpreterInterrupted(EvalFrame* inEvalFrame);

	void onInterpreterInterruptedForVectorLoad(EvalFrame* inEvalFrame);

	void onInterpreterResumedWithValue(EvalFrame* inEvalFrame, bool isException);

	//the interpreter produced an axiom result
	void onAxiomResult(EvalFrame* inEvalFrame, bool isException);

	void onNewStackframe(EvalFrame* inEvalFrame);

	void onReturnedToInterpreter(EvalFrame* inEvalFrame, bool isException);

	void onBranch(EvalFrame* inEvalFrame, long whichBranch);

	void onCachecall();

	//if we've tripped a loop counter, give the expected loop cycle length
	Nullable<size_t> hasTrippedLoopTrigger(size_t minExpectedCycles);

	void setExternalTraceHandler(boost::function1<void, const Fora::InterpreterTraceTerm&> handler);

	boost::function1<void, const Fora::InterpreterTraceTerm&> getExternalTraceHandler();

private:
	boost::shared_ptr<InterpreterHistoryImpl> mImpl;

	boost::shared_ptr<ExecutionContextConfiguration> mConfig;
};


}
}
