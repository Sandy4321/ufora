#pragma once

#include "../../core/PolymorphicSharedPtr.hpp"
#include "../Axioms/Axioms.hppml"
#include "JudgmentBundle.hppml"
#include "JudgmentBundleScope.hppml"
#include "../ControlFlowGraph/ControlFlowGraph.hppml"

namespace TypedFora {

class Compiler;

}

/********************************

Given an entrypoint apply judgment, this class determines whether the
resulting apply is "simple", meaning that it follows a simple path that
doesn't touch any instruction more than once, and performs only simple
tuple/class operations (e.g. packing, unpacking, binding, mixins etc.)

Essentially, "simple" applies don't do very much work, and it's expensive
to use the entire judgment framework on them. This infrastructure helps
identify and optimize these cases.

*********************************/

namespace Fora {

class SimpleForwardReasoner : public PolymorphicSharedPtrBase<SimpleForwardReasoner> {
public:
	@type State = 
		ControlFlowGraph graph,
		ImmutableTreeVector<Fora::JudgmentBundle> judgments,
		ImmutableTreeSet<Fora::FilterVariable> filtersActive,
		Nullable<std::string> label
		;

	@type Result = 
		JudgmentBundle resultBundle,
		bool isException,
		ImmutableTreeSet<Fora::FilterVariable> filtersActive
		;

	SimpleForwardReasoner(
			PolymorphicSharedPtr<TypedFora::Compiler> inCompiler,
			PolymorphicSharedPtr<Axioms> inAxioms,
			JudgmentOnValueTuple applyJov
			);

	JudgmentBundleTuple initialApplyBundle() const;

	bool isSimple() const;

	Nullable<Result> simpleResult() const;

private:
	JudgmentBundleScope mScope;

	JudgmentBundleTuple mInitialApplyBundle;

	Nullable<Result> mSimpleResult;

	Nullable<Result> propagateState(State curState);

	PolymorphicSharedPtr<TypedFora::Compiler> mCompiler;

	PolymorphicSharedPtr<Axioms> mAxioms;
};

}