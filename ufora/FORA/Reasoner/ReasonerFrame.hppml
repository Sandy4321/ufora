#pragma once

#include "../../core/PolymorphicSharedPtr.hpp"
#include "../../core/containers/MapWithIndex.hpp"
#include "../Judgment/JudgmentOnAction.hppml"
#include "ReasonerEntrypoint.hppml"

namespace TypedFora {

class Compiler;

}

namespace Fora {

class SimpleForwardReasoner;

class ReasonerFrame : public PolymorphicSharedPtrBase<ReasonerFrame> {
public:
	ReasonerFrame(const ReasonerEntrypoint& entrypoint);

	hash_type hash() const;

	void recalculate(SimpleForwardReasoner& ioReasoner);

	JudgmentOnAction exits() const;

	ControlFlowGraph graph() const;

	ImmutableTreeVector<JOV> entryJOVs() const;

	const MapWithIndex<Nullable<std::string>, ReasonerEntrypoint>& getCalledFrames() const;

	//indicate that the exits from an entrypoint in 'getCalledFrames' has changed its exit types
	void entrypointExitsChanged(const ReasonerEntrypoint& downstreamEntrypoint);

	//called if we discover that we recurse. Should return whether this dirties us.
	bool recursedToSameGraph(SimpleForwardReasoner& ioReasoner, const ReasonerEntrypoint& downstreamEntrypoint);

	ImmutableTreeVector<JOV> jovsFor(Nullable<std::string> label) const;

	const std::set<Nullable<std::string> >& unknownApplyNodes() const;

private:
	void processNode(
			const Nullable<std::string>& label,
			SimpleForwardReasoner& ioReasoner
			);

	void followContinuation(
			const Nullable<std::string>& label,
			const ControlFlowContinuation& continuation, 
			const ImmutableTreeVector<JOV>& jovs,
			const ControlFlowNodeBody& nodeBody,
			const Nullable<JOV>& result
			);

	ControlFlowGraph mGraph;

	ImmutableTreeVector<JOV> mEntryJovs;

	MapWithIndex<Nullable<std::string>, ReasonerEntrypoint> mCalledFrames;

	map<Nullable<std::string>, ImmutableTreeVector<JOV> > mNodeJOVs;

	map<Nullable<std::string>, JudgmentOnAction> mNodeExits;

	std::set<Nullable<std::string> > mDirtyNodes;

	std::set<Nullable<std::string> > mUnknownApplyNodes;

	JudgmentOnAction mExits;

	hash_type mHash;
};

}

