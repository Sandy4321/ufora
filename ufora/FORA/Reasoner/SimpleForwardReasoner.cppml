#include "SimpleForwardReasoner.hppml"
#include "../Judgment/ControlFlowGraphJudgmentUtil.hppml"
#include "../../core/Logging.hpp"
#include "../../core/Clock.hpp"
#include "../Axioms/Axiom.hppml"
#include "../Axioms/AxiomGroup.hppml"

namespace Fora {

SimpleForwardReasoner::SimpleForwardReasoner(
			PolymorphicSharedPtr<TypedFora::Compiler> inCompiler,
			PolymorphicSharedPtr<Axioms> inAxioms
			) : 
		mAxioms(inAxioms),
		mCompiler(inCompiler)
	{
	}

PolymorphicSharedPtr<Axioms> SimpleForwardReasoner::getAxioms() const
	{
	return mAxioms;
	}

TypedFora::Compiler& SimpleForwardReasoner::getCompiler()
	{
	return *mCompiler;
	}

PolymorphicSharedPtr<ReasonerFrame> SimpleForwardReasoner::getFrameFor(const ReasonerEntrypoint& entrypoint)
	{
	auto& result = mFrames[entrypoint];

	if (!result)
		{
		LOG_DEBUG << "Created a new frame at " << entrypoint;

		result.reset(new ReasonerFrame(entrypoint));
		mGraph.markDirty(entrypoint);
		}

	return result;
	}


PolymorphicSharedPtr<ReasonerFrame> SimpleForwardReasoner::reason(JudgmentOnValueTuple applyJovt)
	{
	auto axiom = mAxioms->axiom(*mCompiler, applyJovt);

	lassert(axiom);
	lassert(!applyJovt.hasExtras());

	//start by expanding the apply tuple
	@match Axiom(*axiom)
		-| Expands(jovt, generator) ->> {
			auto cfg = generator(ApplySignature(applyJovt.jovs().size()));

			ReasonerEntrypoint entrypoint = ReasonerEntrypoint(cfg, applyJovt.jovs());

			mGraph.addRoot(entrypoint);

			auto frame = getFrameFor(entrypoint);

			updateAll();

			return frame;
			}
	}

void SimpleForwardReasoner::updateAll()
	{
	while (auto nEntrypoint = mGraph.popDirtyReachableFrame())
		updateFrame(*nEntrypoint);
	}

void SimpleForwardReasoner::updateFrame(const ReasonerEntrypoint& entrypoint)
	{
	auto frame = getFrameFor(entrypoint);

	JudgmentOnAction priorJOA = frame->exits();

	MapWithIndex<Nullable<std::string>, ReasonerEntrypoint> calledFrames = frame->getCalledFrames();

	frame->recalculate(*this);

	MapWithIndex<Nullable<std::string>, ReasonerEntrypoint> newCalledFrames = frame->getCalledFrames();

	std::set<ReasonerEntrypoint> newCalled;

	for (auto& frameAndLabels: newCalledFrames.getValueToKeys())
		newCalled.insert(frameAndLabels.first);

	if (mGraph.setEdges(entrypoint, newCalled))
		checkEntrypointParents(entrypoint);

	if (priorJOA != frame->exits())
		for (auto callingFrame: mGraph.getCallers(entrypoint))
			{
			LOG_DEBUG 
				<< callingFrame << " marked dirty because it called " 
				<< entrypoint 
				<< " whose JOA changed from "
				<< priorJOA << " to "
				<< frame->exits()
				;

			getFrameFor(callingFrame)->entrypointExitsChanged(entrypoint);
			mGraph.markDirty(callingFrame);
			}
	}

void SimpleForwardReasoner::checkEntrypointParents(ReasonerEntrypoint entrypoint)
	{
	std::set<ReasonerEntrypoint> seen;

	std::set<ReasonerEntrypoint> toCheck;
	toCheck.insert(entrypoint);

	while (toCheck.size())
		{
		ReasonerEntrypoint e = *toCheck.begin();
		toCheck.erase(e);

		if (seen.find(e) == seen.end())
			{
			seen.insert(e);
			for (auto caller: mGraph.getCallers(e))
				toCheck.insert(caller);

			if (e.graph() == entrypoint.graph() && e != entrypoint)
				{
				if (getFrameFor(e)->recursedToSameGraph(*this, entrypoint))
					mGraph.markDirty(e);
				if (getFrameFor(entrypoint)->recursedToSameGraph(*this, e))
					mGraph.markDirty(entrypoint);
				}
			}
		}
	}

int64_t SimpleForwardReasoner::totalFrameCount() const
	{
	return mFrames.size();
	}

}