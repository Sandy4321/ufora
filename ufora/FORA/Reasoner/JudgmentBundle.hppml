/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#pragma once

#include "../Judgment/JudgmentOnValue.hppml"
#include "../Core/ClassMediator.hppml"
#include "../Core/ClassBody.hppml"

namespace Fora {

@type FilterVariable = int index;

macro_defineCppmlComparisonOperators(FilterVariable)

@type SelectorVariable = int index;

macro_defineCppmlComparisonOperators(SelectorVariable)

@type JudgmentBundle = 
	-| Constant of 
		JudgmentOnValue value
	-| Tuple of JudgmentBundleTuple tuple
	-| Class of 
		ClassBody mediator, 
		ImmutableTreeVector<JudgmentBundle> subBundles
	-| Filter of 
		ImmutableTreeSet<FilterVariable> variables, 
		JudgmentOnValue ifAnyFalse,
		JudgmentBundle ifAllTrue
	-| Selector of 
		SelectorVariable variable,
		JudgmentBundle ifTrue,
		JudgmentBundle ifFalse
	with
		JOV coverageJOV = (this->computeCoverageJOV()),
		ImmutableTreeSet<FilterVariable> filterVariables = (this->computeFilterVariables()),
		ImmutableTreeSet<SelectorVariable> selectorVariables = (this->computeSelectorVariables())
	{
	public:
		JOV computeCoverageJOV() const;

		static JudgmentBundle FilterIfNonempty(
						const ImmutableTreeSet<FilterVariable>& variables, 
						const JudgmentOnValue& ifAnyFalse,
						const JudgmentBundle& ifAllTrue
						);

		ImmutableTreeSet<FilterVariable> computeFilterVariables() const;

		ImmutableTreeSet<SelectorVariable> computeSelectorVariables() const;

		//the set of filter variables that are at the top level of the tree
		//(e.g. not hidden below other filter variables or selector variables)
		ImmutableTreeSet<FilterVariable> immediateFilterVariables() const;

		//the set of selector variables that are at the top level of the tree
		//(e.g. not hidden below other filter variables or selector variables)
		ImmutableTreeSet<SelectorVariable> immediateSelectorVariables() const;

		JudgmentBundle resolve(
							ImmutableTreeMap<FilterVariable, bool> filterVars, 
							ImmutableTreeMap<SelectorVariable, bool> selectorVars
							) const;

		JudgmentBundle resolveToTrue(ImmutableTreeSet<FilterVariable> vars) const;

		JudgmentBundle resolve(FilterVariable var, bool value) const;

		JudgmentBundle resolve(SelectorVariable var, bool value) const;

		Nullable<ImmutableTreeSet<FilterVariable> > minimumFilterRequiredToBeCoveredBy(JOV jov) const;

		static JudgmentBundle Tuple(
						ImmutableTreeVector<JudgmentBundle> subBundles,
						ImmutableTreeVector<Nullable<Symbol> > names
						);
	}
and
	JudgmentBundleTupleExtras =
			NoExtras of ()
		-|	Extras of JudgmentBundle judgment
	{
	public:
		JudgmentOnValueTupleExtras coverageJOV() const;

		ImmutableTreeSet<FilterVariable> filterVariables() const;

		ImmutableTreeSet<SelectorVariable> selectorVariables() const;

		ImmutableTreeSet<FilterVariable> immediateFilterVariables() const;

		ImmutableTreeSet<SelectorVariable> immediateSelectorVariables() const;

		JudgmentBundleTupleExtras resolve(
							ImmutableTreeMap<FilterVariable, bool> filterVars, 
							ImmutableTreeMap<SelectorVariable, bool> selectorVars
							) const;
	}
and
	JudgmentBundleTuple = 
		ImmutableTreeVector<JudgmentBundle> subBundles,
		ImmutableTreeVector<Nullable<Symbol> > names,
		JudgmentBundleTupleExtras extras
	{
	public:
		ImmutableTreeSet<FilterVariable> filterVariables() const;

		ImmutableTreeSet<SelectorVariable> selectorVariables() const;

		ImmutableTreeSet<FilterVariable> immediateFilterVariables() const;

		ImmutableTreeSet<SelectorVariable> immediateSelectorVariables() const;

		JudgmentBundleTuple resolve(
						ImmutableTreeMap<FilterVariable, bool> filterVars, 
						ImmutableTreeMap<SelectorVariable, bool> selectorVars
						) const;

		static JudgmentBundleTuple concatenate(
						JudgmentBundleTuple left,
						JudgmentBundleTuple right
						);

		JOVT coverageJOVT() const;

		Nullable<ImmutableTreeSet<FilterVariable> > minimumFilterRequiredToBeCoveredBy(JOVT jov) const;
	};

}

template<>
class CPPMLPrettyPrint<Fora::JudgmentBundle> {
public:
		static void prettyPrint(CPPMLPrettyPrintStream& s, const Fora::JudgmentBundle& t);
};

template<>
class CPPMLPrettyPrint<Fora::FilterVariable> {
public:
		static void prettyPrint(CPPMLPrettyPrintStream& s, const Fora::FilterVariable& t);
};

template<>
class CPPMLPrettyPrint<Fora::SelectorVariable> {
public:
		static void prettyPrint(CPPMLPrettyPrintStream& s, const Fora::SelectorVariable& t);
};

template<>
class CPPML::Validator<Fora::JudgmentBundle_FilterType, void> {
public:
	void operator()(Fora::JudgmentBundle_FilterType& filter) const;
};

