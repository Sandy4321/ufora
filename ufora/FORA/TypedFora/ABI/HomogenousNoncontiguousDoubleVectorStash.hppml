/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#pragma once

#include "../../../core/Common.hppml"
#include "VectorRecord.hpp"
#include "ForaValueArray.hppml"

namespace TypedFora {
namespace Abi {

class HomogenousDoubleVectorStashRecord;

/***********************************
HomogenousNoncontiguousDoubleVectorStash

A datastructure that supports fast cache-local accesses into a vector
of the form
	
	v[offset1][offset2]

**********************************/

@type HomogenousNoncontiguousDoubleVectorStash = 
	int64_t offset1Start,
	int64_t offset1Stop,
	pair<int64_t, int64_t>* validRangeTable,
	pair<uint8_t*, int64_t>* pointerAndStrideTable,
	HomogenousDoubleVectorStashRecord* stashRecord
{
public:
	static HomogenousNoncontiguousDoubleVectorStash withStashRecord(HomogenousDoubleVectorStashRecord* rec)
		{
		return HomogenousNoncontiguousDoubleVectorStash(0,0,nullptr,nullptr,rec);
		}

	static HomogenousNoncontiguousDoubleVectorStash canonicalOutOfBoundsDim1()
		{
		return HomogenousNoncontiguousDoubleVectorStash(1,0,nullptr,nullptr,nullptr);
		}

	static HomogenousNoncontiguousDoubleVectorStash canonicalOutOfBoundsDim2()
		{
		return HomogenousNoncontiguousDoubleVectorStash(2,0,nullptr,nullptr,nullptr);
		}
	
	bool dim1IsOutOfBounds() const
		{
		return offset1Stop() < offset1Start() && offset1Start() == 1;
		}

	bool dim2IsOutOfBounds() const
		{
		return offset1Stop() < offset1Start() && offset1Start() == 2;
		}

	uint8_t* offsetFor(int64_t offset1, int64_t offset2) const
		{
		if (offset1 < offset1Start() || offset1 >= offset1Stop())
			return nullptr;

		auto range = validRangeTable()[offset1];

		if (offset2 < range.first || offset1 >= range.second)
			return nullptr;

		return nullptr;
		}

	uint8_t* offsetForInBounds(int64_t offset1, int64_t offset2) const
		{
		auto pointerAndStride = pointerAndStrideTable()[offset1];
		return pointerAndStride.first + offset2 * pointerAndStride.second;
		}

	static VectorLoadRequest getLoadRequest(
						TypedFora::Abi::VectorRecord handle,
						int64_t offset1,
						int64_t offset2,
						//how many bytes into v[offset1] is the second vector record?
						int64_t offsetWithinRecord1
						);

	//create a double-vector-stash, which models v[offset1][offset2]. We attempt to give
	//the largest square region that can be read into in the source vector. If offset1 or
	//offset2 is out of bounds, we return a stash with stop<start in the appropriate region.
	//if we need a vector loaded, we return stop==start.
	static HomogenousNoncontiguousDoubleVectorStash updateStash(
						HomogenousNoncontiguousDoubleVectorStash currentStashRecord,
						TypedFora::Abi::PooledVectorRecord handle,
						int64_t offset1,
						int64_t offset2,
						//how many bytes into v[offset1] is the second vector record?
						int64_t offsetWithinRecord1
						);
};

}
}

